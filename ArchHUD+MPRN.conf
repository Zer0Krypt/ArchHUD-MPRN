name: ArchHud+MPRN v1.413 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        useTheseSettings = false --export:
        userControlScheme = "virtual joystick" --export:
        soundFolder = "archHUD" --export:
        freeLookToggle = true --export:
        BrakeToggleDefault = true --export:
        RemoteFreeze = false --export:
        RemoteHud = true --export:
        brightHud = false --export:
        VanillaRockets = false --export:
        InvertMouse = false --export:
        autoRollPreference = false --export:
        ExternalAGG = false --export:
        UseSatNav = false --export:
        ShouldCheckDamage = true --export:
        CalculateBrakeLandingSpeed = false --export:
        AtmoSpeedAssist = true --export:
        ForceAlignment = false --export:
        DisplayDeadZone = true --export:
        showHud = true --export: 
        ShowOdometer = true --export:
        hideHudOnToggleWidgets = true --export:
        ShiftShowsRemoteButtons = true --export:
        DisplayOrbit = true --export: 
        SetWaypointOnExit = false --export:
        AlwaysVSpd = false --export:
        BarFuelDisplay = true --export:
        Cockpit = false --export:
        voices = true --export:
        alerts = true --export:
        CollisionSystem = true --export:
        YawStallAngle = 35 --export:
        PitchStallAngle = 35 --export:
        brakeLandingRate = 30 --export:
        MaxPitch = 30 --export:
        ReEntryPitch = -30 --export:
        LockPitchTarget = 0 --export:
        AutopilotSpaceDistance = 5000 --export:
        TargetOrbitRadius = 1.4 --export:
        LowOrbitHeight = 1000 --export:
        AtmoSpeedLimit = 1050 --export:
        SpaceSpeedLimit = 30000 --export:
        AutoTakeoffAltitude = 1000 --export:
        TargetHoverHeight = 50 --export:
        LandingGearGroundHeight = 0 --export:
        ReEntryHeight = 100000 --export:
        MaxGameVelocity = 8333.00 --export:
        AutopilotInterplanetaryThrottle = 1.0 --export:
        warmup = 32 --export:
        fuelTankHandlingAtmo = 0 --export:
        fuelTankHandlingSpace = 0 --export:
        fuelTankHandlingRocket = 0 --export:
        ContainerOptimization = 0 --export:
        FuelTankOptimization = 0 --export:
        ResolutionX = 1920 --export:
        ResolutionY = 1080 --export:
        circleRad = 400 --export:
        SafeR = 130 --export:
        SafeG = 224 --export:
        SafeB = 255 --export:
        PvPR = 255 --export:
        PvPG = 0 --export:
        PvPB = 0 --export:
        centerX = 960 --export:
        centerY = 540 --export:
        throtPosX = 1300 --export:
        throtPosY = 540 --export:
        vSpdMeterX = 1525  --export:
        vSpdMeterY = 325 --export:
        altMeterX = 550  --export:
        altMeterY = 540 --export:
        fuelX = 30 --export:
        fuelY = 700 --export:
        shieldX = 1750 --export:
        shieldY = 250 --export:
        DeadZone = 50 --export:
        OrbitMapSize = 250 --export:
        OrbitMapX = 75 --export:
        OrbitMapY = 0 --export:
        soundVolume = 100 --export:
        speedChangeLarge = 5 --export:
        speedChangeSmall = 1 --export:
        MouseXSensitivity = 0.003 --export:
        MouseYSensitivity = 0.003 --export:
        autoRollFactor = 2 --export:
        rollSpeedFactor = 1.5 --export:
        autoRollRollThreshold = 180 --export:
        minRollVelocity = 150 --export:
        TrajectoryAlignmentStrength = 0.002 --export:
        torqueFactor = 2 --export:
        pitchSpeedFactor = 0.8 --export:
        yawSpeedFactor = 1 --export:
        brakeSpeedFactor = 3 --export:
        brakeFlatFactor = 1 --export:
        DampingMultiplier = 40 --export:
        apTickRate = 0.0166667 --export:
        hudTickRate = 0.0666667 --export:
        ExtraLongitudeTags = "none" --export:
        ExtraLateralTags = "none" --export:
        ExtraVerticalTags = "none" --export:
        distanceThreshold = 5000 --export:
        wpList = route --export:
        local a=Navigator.new(system,core,unit)script={}VERSION_NUMBER=1.413;mprnStatus='OFF'speedThreshold=500;currentSpeed=0;inRange=false;inSpeed=false;currentWayPoint=0;inTargetRange=0;lastBrakeLanding=false;lastAutopilotBraking=false;BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;iphCondition="All"stablized=true;UseExtra="Off"local b={"VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime","iphCondition","stablized","UseExtra"}local c=math.abs;local d=math.floor;local e=string.format;local f=json.decode;local g=json.encode;local h=core.getElementMaxHitPointsById;local j=unit.getAtmosphereDensity;local k=core.getElementMassById;local l=a.control.isRemoteControlled;local m=math.atan;local n=string.match;local o=system.getTime;local vec3=vec3;local q=utils.clamp;local r=a.axisCommandManager;local s=system.destroyWidgetPanel;local t=system.updateData;local u=system.addDataToWidget;local v=system.lockView;local w=system.isViewLocked;local x=math.sqrt;local y=tonumber;local core=core;local function z(A,B)local C=10^(B or 0)return d(A*C+0.5)/C end;local D=o()local E=o()local F=16;local G=13;local H=SafeR;local I=SafeB;local J=SafeG;local K=0;local L=0;local M=false;local N=0;local O=false;local P=false;local Q=55;local R=false;local S=false;local T=0;local U=0;local V=0;local W=0;local X=0;local Y=0;local Z=0;local a0=false;local a1=false;local a2="empty"local a3=5;local a4=5;local a5=a3;local a6=a4;local a7=false;local a8,a9=0;local aa,ab=0;local ac=nil;local ad=0;local ae=0;local af=0;local ag=0;local ah=0;local ai=3;local aj=0;local ak=""local al=false;local am=false;local an=false;local ao=-1;local ap=""local aq=j()>0;local ar=j()local as=core.getAltitude()local at=core.getElementIdList()local au=o()local av=core.getConstructMass()local aw=false;local ax=nil;local ay=[[rgb(]]..d(H+0.5)..","..d(J+0.5)..","..d(I+0.5)..[[)]]local az=[[rgb(]]..d(H*0.9+0.5)..","..d(J*0.9+0.5)..","..d(I*0.9+0.5)..[[)]]local aA={}local aB=0;local aC=0;local aD=""local aE=true;local aF={}local aG=ResolutionX;local aH=ResolutionY;local aI={}local aJ={}local aK={}local aL=0;local aM=false;local aN=nil;local aO=nil;local aP=nil;local aQ=nil;local aR=nil;local aS=nil;local aT=nil;local aU=nil;local aV=nil;local aW=nil;local aX=nil;local aY=nil;local aZ=nil;local a_=false;local b0=false;local b1=autoRollPreference;local b2=LandingGearGroundHeight;local b3=false;local b4=o()local b5=0;local b6=0;local b7=0;local b8=AtmoSpeedLimit;local b9=0;local ba=nil;local bb=0;local bc=0;local bd=false;local be=false;local bf={VectorToTarget=false}local bg=false;local bh=0;local bi=nil;local bj=false;local bk=false;local bl=false;local bm=false;local bn=0;local bo=vec3(core.getConstructWorldOrientationUp())local bp=vec3(core.getConstructWorldOrientationForward())local bq=vec3(core.getConstructWorldOrientationRight())local br=vec3(core.getVelocity())local bs=vec3(core.getWorldVelocity())local bt=vec3(bs):len()local bu=vec3(core.getWorldVertical())local bv=-bu:dot(bs)local bw=vec3(core.getConstructWorldPos())local bx=0;local by=false;local bz=false;local bA=nil;local bB=true;local bC=0;local bD=0;local bE=false;local bF={}local bG=showHud;local bH={}local bI=false;local bJ=""local bK=nil;local bL={}local bM=unit.getClosestPlanetInfluence()>0 or as>0 and as<200000;local bN=false;local bO=nil;local function bP(bQ)local bR,bS,bT=aS:getPlanetarySystem(0):castIntersections(bw,bQ,function(bU)if bU.noAtmosphericDensityAltitude>0 then return bU.radius+bU.noAtmosphericDensityAltitude else return bU.radius+bU.surfaceMaxAltitude*1.5 end end)local bV=bS;if bT~=nil and bS~=nil then bV=math.min(bT,bS)end;if bV~=nil then return bR,bV else return nil,nil end end;local function bW(bX,bY,type)if type==nil and not voices or type~=nil and not alerts or soundFolder=="archHUD"then return end;if type~=nil then if type==2 then system.logInfo("sound_loop|audiopacks/"..soundFolder.."/"..bX.."|"..bY.."|"..soundVolume)else system.logInfo("sound_notification|audiopacks/"..soundFolder.."/"..bX.."|"..bY.."|"..soundVolume)end else system.logInfo("sound_q|audiopacks/"..soundFolder.."/"..bX.."|"..bY.."|"..soundVolume)end end;local function bZ(b_,c0)for i=1,#c0 do b_[#b_+1]=c0[i]end;return b_ end;local function c1(c2)local c3={}local c4={"userControlScheme","soundFolder","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","ShowOdometer","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","DisplayOrbit","SetWaypointOnExit","AlwaysVSpd","BarFuelDisplay","Cockpit","voices","alerts","CollisionSystem"}local c5={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","ReEntryPitch","LockPitchTarget","AutopilotSpaceDistance","TargetOrbitRadius","LowOrbitHeight","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","ReEntryHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization"}local c6={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","shieldX","shieldY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY","soundVolume"}local c7={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not c2 then bZ(c3,c4)bZ(c3,c5)bZ(c3,c6)bZ(c3,c7)return c3 elseif c2=="boolean"then return c4 elseif c2=="handling"then return c5 elseif c2=="hud"then return c6 elseif c2=="physics"then return c7 end end;local function c8(c9,ca,cb,cc,cd)if cc==nil then cc=""end;if cd==nil then cd=""end;return e([[<text class="%s" x=%s y=%s style="%s">%s</text>]],cc,c9,ca,cd,cb)end;local function ce(cf,cg)if r:getAxisCommandType(0)~=axisCommandType.byThrottle and not cg then a.control.cancelCurrentControlMasterMode()end;r:setThrottleCommand(axisCommandId.longitudinal,cf)K=q(z(cf*100,0)/100,-1,1)end;local function ch(cf,cg)if r:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not cg then a.control.cancelCurrentControlMasterMode()end;r:setTargetSpeedCommand(axisCommandId.longitudinal,cf)bA=cf end;local function ci(cj,ck)if cj==0 then return c(ck)<1e-09 end;if ck==0 then return c(cj)<1e-09 end;return c(cj-ck)<math.max(c(cj),c(ck))*epsilon end;local function cl(aj,cm)local cn=aj>100000;if cm==nil then cm=1 end;if cn then return z(aj/1000/200,cm).."SU"elseif aj<1000 then return z(aj,cm).."M"else return z(aj/1000,cm).."KM"end end;local function co()AltitudeHold=false;if VertTakeOff then StrongBrakes=true;Reentry=false;AutoTakeoff=false;BrakeLanding=true;b1=true;af=0;if aq and ao==-1 then BrakeLanding=false;AltitudeHold=true;af=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)ch(d(b8))end else bj=false;GearExtended=false;a.control.retractLandingGears()r:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end;VertTakeOff=not VertTakeOff end;local function cp()bj=false;bb=nil;bc=nil;bn=0;if ar==0 then if IntoOrbit then bW("orOff","AP")IntoOrbit=false;bd=false;bi=nil;b1=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;bf.VectorToTarget=false;bf.AutopilotAlign=false;bg=false elseif bM then bW("orOn","AP")IntoOrbit=true;b1=true;if bi==nil then bi=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else a2="Unable to engage auto-orbit, not near a planet"end else IntoOrbit=false;bd=false;bi=nil;b1=autoRollPreference;if AltitudeHold then AltitudeHold=false end;bf.VectorToTarget=false;bf.AutopilotAlign=false;bg=false end end;local function cq()if D-b6<1.5 then if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude;bW("11","EP")else if bM then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bh=HoldAltitude;bg=true;if not IntoOrbit then cp()end;bd=true end end;b6=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else b6=D end;if bM and ar==0 then bh=as;bg=true;bd=true;cp()if IntoOrbit then b6=D else b6=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;a0=false;b1=true;LockPitch=nil;bj=false;if ao~=-1 and bt<20 then bW("lfs","LS")AutoTakeoff=true;if b6>-1 then HoldAltitude=as+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;r:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and by then co()end else bW("altOn","AH")AutoTakeoff=false;if b6>-1 then if bM then HoldAltitude=as end end;if VertTakeOff then co()end end;if am then HoldAltitude=100000 end else bW("altOff","AH")if IntoOrbit then cp()end;if VertTakeOff then co()end;b1=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;b6=0 end end;local function cr()local function cs(SpaceTarget)bN=false;VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then cq()end end;VectorStatus="Proceeding to Waypoint"end;if D-b7<1.5 and ar>0 then if not bm then a2="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bW("orH","OH")end;b7=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else b7=D end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not am and not IntoOrbit then if 0.5*a:maxForceForward()/core.g()<av then a2="WARNING: Heavy Loads may affect autopilot performance."ai=5 end;aX.UpdateAutopilotTarget()aY.showWayPoint(ac,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then bW("apSpc","AP")if ar~=0 then am=true;cq()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if ar>0 then if not VectorToTarget then bW("vtt","AP")cs(SpaceTarget)end else bW("apOn","AP")if not(ac.name==planet.name and bM)then bj=false;Autopilot=true elseif not aq then if IntoOrbit then cp()end;bh=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bg=true;bf.AutopilotAlign=true;bf.VectorToTarget=true;bd=false;if not IntoOrbit then cp()end end end else bW("apP","AP")RetrogradeIsOn=false;ProgradeIsOn=false;if ar~=0 then am=true;cq()else Autopilot=true end end elseif ar==0 then if CustomTarget==nil and(ac.name==planet.name and bM)and not IntoOrbit then WaypointSet=false;bj=false;bd=false;cp()else bW("apP","AP")Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;a0=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;P=false;LockPitch=nil;WaypointSet=false end else bW("apP","AP")am=true;cq()end else bW("apOff","AP")am=false;Autopilot=false;AutopilotRealigned=false;VectorToTarget=false;P=false;AutoTakeoff=false;AltitudeHold=false;HoldAltitude=as;TargetSet=false;Reentry=false;if IntoOrbit then cp()end end end;local function ct()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;b1=autoRollPreference end;if BrakeIsOn then bW("bkOn","B",1)VectorToTarget=false;AutoTakeoff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;bK=nil;if not bz then AltitudeHold=false;LockPitch=nil end;if VertTakeOff then co()end;if IntoOrbit then cp()end;b1=autoRollPreference;al=false;an=false;af=0 else bW("bkOff","B",1)end end;local function cu()if Reentry then a2="Re-Entry cancelled"bW("reOff","RE")Reentry=false;b1=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then a2="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ai=5 elseif not R then Reentry=true;if r:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;b1=true;BrakeIsOn=false;a2="Beginning Parachute Re-Entry - Strap In.  Target speed: "..b8;bW("par","RE")else Reentry=true;AltitudeHold=true;b1=true;BrakeIsOn=false;HoldAltitude=planet.surfaceMaxAltitude+ReEntryHeight;if HoldAltitude>planet.spaceEngineMinAltitude then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude end;local cb=cl(HoldAltitude)a2="Beginning Re-entry.  Target speed: "..b8 .." Target Altitude: "..cb;bW("glide","RE")ch(d(b8))end;AutoTakeoff=false end;local function cv()if antigrav and not ExternalAGG then if bz then bW("aggOff","AG")antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;bW("aggOn","AG")antigrav.activate()antigrav.show()end end end;local function cw(cx)local cy=0;local cz=0;local cA=0;if cx<60 then cx=d(cx)elseif cx<3600 then cy=d(cx/60)cx=d(cx%60)elseif cx<86400 then cz=d(cx/3600)cy=d(cx%3600/60)else cA=d(cx/86400)cz=d(cx%86400/3600)end;if cA>0 then return cA.."d "..cz.."h "elseif cz>0 then return cz.."h "..cy.."m "elseif cy>0 then return cy.."m "..cx.."s"elseif cx>0 then return cx.."s"else return"0s"end end;local function cB(cC)local function cD(cE)for cF,cG in pairs(cE)do dbHud_1.setStringValue(cG,g(_G[cG]))if cC and dbHud_2 then dbHud_2.setStringValue(cG,g(_G[cG]))end end end;if dbHud_1 then cD(b)cD(c1())system.print("Saved Variables to Datacore")if cC and dbHud_2 then a2="Databank copied.  Remove copy when ready."end end end;local function cH()return{[0]={[0]={GM=0,bodyId=0,center={x=0,y=0,z=0},name='Space',planetarySystemId=0,radius=0,hasAtmosphere=false,gravity=0,noAtmosphericDensityAltitude=0,surfaceMaxAltitude=0},[2]={name="Alioth",description="Alioth is the planet selected by the arkship for landfall; it is a typical goldilocks planet where humanity may rebuild in the coming decades. The arkship geological survey reports mountainous regions alongside deep seas and lush forests. This is where it all starts.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9401,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=2,GM=157470826617,gravity=1.0082568597356114,fullAtmosphericDensityMaxAltitude=-10,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6272,numSatellites=2,positionFromSun=2,center={x=-8,y=-8,z=-126303},radius=126067.8984375,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=3410,surfaceArea=199718780928,surfaceAverageAltitude=200,surfaceMaxAltitude=1100,surfaceMinAltitude=-330,systemZone="High",territories=259472,type="Planet",waterLevel=0,planetarySystemId=0},[21]={name="Alioth Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=21,GM=2118960000,gravity=0.24006116402380084,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=457933,y=-1509011,z=115524},radius=30000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=11309733888,surfaceAverageAltitude=140,surfaceMaxAltitude=200,surfaceMinAltitude=10,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[22]={name="Alioth Moon 4",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=22,GM=2165833514,gravity=0.2427018259886451,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-1692694,y=729681,z=-411464},radius=30330,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=11559916544,surfaceAverageAltitude=-15,surfaceMaxAltitude=-5,surfaceMinAltitude=-50,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[5]={name="Feli",description="Feli is easily identified by its massive and deep crater. Outside of the crater, the arkship geological survey reports a fairly bland and uniform planet, it also cannot explain the existence of the crater. Feli is particular for having an extremely small atmosphere, allowing life to develop in the deeper areas of its crater but limiting it drastically on the actual surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.5488,atmosphericEngineMaxAltitude=66725,biosphere="Barren",classification="Mesoplanet",bodyId=5,GM=16951680000,gravity=0.4801223280476017,fullAtmosphericDensityMaxAltitude=30,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=78500,numSatellites=1,positionFromSun=5,center={x=-43534464,y=22565536,z=-48934464},radius=41800,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=42800,surfaceArea=21956466688,surfaceAverageAltitude=18300,surfaceMaxAltitude=18500,surfaceMinAltitude=46,systemZone="Low",territories=27002,type="Planet",waterLevel=nil,planetarySystemId=0},[50]={name="Feli Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=50,GM=499917600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-43902841.78,y=22261034.7,z=-48862386},radius=14000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=800,surfaceMaxAltitude=900,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[120]={name="Ion",description="Ion is nothing more than an oversized ice cube frozen through and through. It is a largely inhospitable planet due to its extremely low temperatures. The arkship geological survey reports extremely rough mountainous terrain with little habitable land.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9522,atmosphericEngineMaxAltitude=10480,biosphere="Ice",classification="Hypopsychroplanet",bodyId=120,GM=7135606629,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=-30,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=17700,numSatellites=2,positionFromSun=12,center={x=2865536.7,y=-99034464,z=-934462.02},radius=44950,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=6410,surfaceArea=25390383104,surfaceAverageAltitude=500,surfaceMaxAltitude=1300,surfaceMinAltitude=250,systemZone="Average",territories=32672,type="Planet",waterLevel=nil,planetarySystemId=0},[121]={name="Ion Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=121,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2472916.8,y=-99133747,z=-1133582.8},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=100,surfaceMaxAltitude=200,surfaceMinAltitude=3,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[122]={name="Ion Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=122,GM=176580000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2995424.5,y=-99275010,z=-1378480.7},radius=15000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=-1900,surfaceMaxAltitude=-1400,surfaceMinAltitude=-2100,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[9]={name="Jago",description="Jago is a water planet. The large majority of the planet&apos;s surface is covered by large oceans dotted by small areas of landmass across the planet. The arkship geological survey reports deep seas across the majority of the planet with sub 15 percent coverage of solid ground.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9835,atmosphericEngineMaxAltitude=9695,biosphere="Water",classification="Mesoplanet",bodyId=9,GM=18606274330,gravity=0.5041284298678057,fullAtmosphericDensityMaxAltitude=-90,habitability="Very High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10900,numSatellites=0,positionFromSun=9,center={x=-94134462,y=12765534,z=-3634464},radius=61590,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=5900,surfaceArea=47668367360,surfaceAverageAltitude=0,surfaceMaxAltitude=1200,surfaceMinAltitude=-500,systemZone="Very High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[100]={name="Lacobus",description="Lacobus is an ice planet that also features large bodies of water. The arkship geological survey reports deep oceans alongside a frozen and rough mountainous environment. Lacobus seems to feature regional geothermal activity allowing for the presence of water on the surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7571,atmosphericEngineMaxAltitude=11120,biosphere="Ice",classification="Psychroplanet",bodyId=100,GM=13975172474,gravity=0.45611622622739767,fullAtmosphericDensityMaxAltitude=-20,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=12510,numSatellites=3,positionFromSun=10,center={x=98865536,y=-13534464,z=-934461.99},radius=55650,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=6790,surfaceArea=38917074944,surfaceAverageAltitude=800,surfaceMaxAltitude=1660,surfaceMinAltitude=250,systemZone="Average",territories=50432,type="Planet",waterLevel=0,planetarySystemId=0},[102]={name="Lacobus Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=102,GM=444981600,gravity=0.14403669598391783,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99180968,y=-13783862,z=-926156.4},radius=18000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=4071504128,surfaceAverageAltitude=150,surfaceMaxAltitude=300,surfaceMinAltitude=10,systemZone=nil,territories=5072,type="",waterLevel=nil,planetarySystemId=0},[103]={name="Lacobus Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=103,GM=211503600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99250052,y=-13629215,z=-1059341.4},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=-1380,surfaceMaxAltitude=-1280,surfaceMinAltitude=-1880,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[101]={name="Lacobus Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=101,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=98905288.17,y=-13950921.1,z=-647589.53},radius=15000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=500,surfaceMaxAltitude=820,surfaceMinAltitude=3,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[1]={name="Madis",description="Madis is a barren wasteland of a rock; it sits closest to the sun and temperatures reach extreme highs during the day. The arkship geological survey reports long rocky valleys intermittently separated by small ravines.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8629,atmosphericEngineMaxAltitude=7165,biosphere="Barren",classification="hyperthermoplanet",bodyId=1,GM=6930729684,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=220,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8050,numSatellites=3,positionFromSun=1,center={x=17465536,y=22665536,z=-34464},radius=44300,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=4480,surfaceArea=24661377024,surfaceAverageAltitude=750,surfaceMaxAltitude=850,surfaceMinAltitude=670,systemZone="Low",territories=30722,type="Planet",waterLevel=nil,planetarySystemId=0},[10]={name="Madis Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=10,GM=78480000,gravity=0.08002039003323584,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17448118.224,y=22966846.286,z=143078.82},radius=10000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=1256637056,surfaceAverageAltitude=210,surfaceMaxAltitude=420,surfaceMinAltitude=0,systemZone=nil,territories=1472,type="",waterLevel=nil,planetarySystemId=0},[11]={name="Madis Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=11,GM=237402000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17194626,y=22243633.88,z=-214962.81},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=-700,surfaceMaxAltitude=300,surfaceMinAltitude=-2900,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[12]={name="Madis Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=12,GM=265046609,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17520614,y=22184730,z=-309989.99},radius=15000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[26]={name="Sanctuary",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9666,atmosphericEngineMaxAltitude=6935,biosphere="",classification="",bodyId=26,GM=68234043600,gravity=1.0000000427743831,fullAtmosphericDensityMaxAltitude=-30,habitability="",hasAtmosphere=true,isSanctuary=true,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=0,center={x=-1404835,y=562655,z=-285074},radius=83400,safeAreaEdgeAltitude=0,size="L",spaceEngineMinAltitude=4230,surfaceArea=87406149632,surfaceAverageAltitude=80,surfaceMaxAltitude=500,surfaceMinAltitude=-60,systemZone=nil,territories=111632,type="",waterLevel=0,planetarySystemId=0},[6]={name="Sicari",description="Sicari is a typical desert planet; it has survived for millenniums and will continue to endure. While not the most habitable of environments it remains a relatively untouched and livable planet of the Alioth sector. The arkship geological survey reports large flatlands alongside steep plateaus.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.897,atmosphericEngineMaxAltitude=7725,biosphere="Desert",classification="Mesoplanet",bodyId=6,GM=10502547741,gravity=0.4081039739797361,fullAtmosphericDensityMaxAltitude=-625,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8770,numSatellites=0,positionFromSun=6,center={x=52765536,y=27165538,z=52065535},radius=51100,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=4480,surfaceArea=32813432832,surfaceAverageAltitude=130,surfaceMaxAltitude=220,surfaceMinAltitude=50,systemZone="Average",territories=41072,type="Planet",waterLevel=nil,planetarySystemId=0},[7]={name="Sinnen",description="Sinnen is a an empty and rocky hell. With no atmosphere to speak of it is one of the least hospitable planets in the sector. The arkship geological survey reports mostly flatlands alongside deep ravines which look to have once been riverbeds. This planet simply looks to have dried up and died, likely from solar winds.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9226,atmosphericEngineMaxAltitude=10335,biosphere="Desert",classification="Mesoplanet",bodyId=7,GM=13033380591,gravity=0.4401121421448438,fullAtmosphericDensityMaxAltitude=-120,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=11620,numSatellites=1,positionFromSun=7,center={x=58665538,y=29665535,z=58165535},radius=54950,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=6270,surfaceArea=37944188928,surfaceAverageAltitude=317,surfaceMaxAltitude=360,surfaceMinAltitude=23,systemZone="Average",territories=48002,type="Planet",waterLevel=nil,planetarySystemId=0},[70]={name="Sinnen Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=70,GM=396912600,gravity=0.1360346539426409,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=58969616,y=29797945,z=57969449},radius=17000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=3631681280,surfaceAverageAltitude=-2050,surfaceMaxAltitude=-1950,surfaceMinAltitude=-2150,systemZone=nil,territories=4322,type="",waterLevel=nil,planetarySystemId=0},[110]={name="Symeon",description="Symeon is an ice planet mysteriously split at the equator by a band of solid desert. Exactly how this phenomenon is possible is unclear but some sort of weather anomaly may be responsible. The arkship geological survey reports a fairly diverse mix of flat-lands alongside mountainous formations.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9559,atmosphericEngineMaxAltitude=6920,biosphere="Ice, Desert",classification="Hybrid",bodyId=110,GM=9204742375,gravity=0.3920998898971822,fullAtmosphericDensityMaxAltitude=-30,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=11,center={x=14165536,y=-85634465,z=-934464.3},radius=49050,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=4230,surfaceArea=30233462784,surfaceAverageAltitude=39,surfaceMaxAltitude=450,surfaceMinAltitude=126,systemZone="High",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[4]={name="Talemai",description="Talemai is a planet in the final stages of an Ice Age. It seems likely that the planet was thrown into tumult by a cataclysmic volcanic event which resulted in its current state. The arkship geological survey reports large mountainous regions across the entire planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8776,atmosphericEngineMaxAltitude=9685,biosphere="Barren",classification="Psychroplanet",bodyId=4,GM=14893847582,gravity=0.4641182439650478,fullAtmosphericDensityMaxAltitude=-78,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10890,numSatellites=3,positionFromSun=4,center={x=-13234464,y=55765536,z=465536},radius=57500,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=5890,surfaceArea=41547563008,surfaceAverageAltitude=580,surfaceMaxAltitude=610,surfaceMinAltitude=520,systemZone="Average",territories=52922,type="Planet",waterLevel=nil,planetarySystemId=0},[42]={name="Talemai Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=42,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13058408,y=55781856,z=740177.76},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=720,surfaceMaxAltitude=850,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[40]={name="Talemai Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=40,GM=141264000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13503090,y=55594325,z=769838.64},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=250,surfaceMaxAltitude=450,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[41]={name="Talemai Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=41,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-12800515,y=55700259,z=325207.84},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=190,surfaceMaxAltitude=400,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[8]={name="Teoma",description="[REDACTED] The arkship geological survey [REDACTED]. This planet should not be here.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7834,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=8,GM=18477723600,gravity=0.48812434578525177,fullAtmosphericDensityMaxAltitude=15,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6280,numSatellites=0,positionFromSun=8,center={x=80865538,y=54665536,z=-934463.94},radius=62000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=3420,surfaceArea=48305131520,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=-200,systemZone="High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[3]={name="Thades",description="Thades is a scorched desert planet. Perhaps it was once teaming with life but now all that remains is ash and dust. The arkship geological survey reports a rocky mountainous planet bisected by a massive unnatural ravine; something happened to this planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.03552,atmosphericEngineMaxAltitude=32180,biosphere="Desert",classification="Thermoplanet",bodyId=3,GM=11776905000,gravity=0.49612641213015557,fullAtmosphericDensityMaxAltitude=150,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=32800,numSatellites=2,positionFromSun=3,center={x=29165536,y=10865536,z=65536},radius=49000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=21400,surfaceArea=30171856896,surfaceAverageAltitude=13640,surfaceMaxAltitude=13690,surfaceMinAltitude=370,systemZone="Low",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[30]={name="Thades Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=30,GM=211564034,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29214402,y=10907080.695,z=433858.2},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=60,surfaceMaxAltitude=300,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[31]={name="Thades Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=31,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29404193,y=10432768,z=19554.131},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=70,surfaceMaxAltitude=350,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0}}}end;local function cI()local function cJ(cK)return type(cK)=='number'end;local function cL(cK)return type(y(cK))=='number'end;local function cM(cN)return type(cN)=='table'end;local function cO(cP)return type(cP)=='string'end;local function cQ(cG)return cM(cG)and cJ(cG.x and cG.y and cG.z)end;local function cR(cS)return cM(cS)and cJ(cS.latitude and cS.longitude and cS.altitude and cS.bodyId and cS.systemId)end;local cT=math.pi/180;local cU=180/math.pi;local epsilon=1e-10;local A=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cV='::pos{'..A..','..A..','..A..','..A..','..A..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function cW(cK)local cX=string.gsub(string.reverse(e('%.4f',cK)),'^0*%.?','')return cX==''and'0'or string.reverse(cX)end;local function cY(cZ)if cQ(cZ)then return e('{x=%.3f,y=%.3f,z=%.3f}',cZ.x,cZ.y,cZ.z)end;if cM(cZ)and not getmetatable(cZ)then local c_={}local d0=next(cZ)if type(d0)=='nil'or d0==1 then c_=cZ else for cF,cG in pairs(cZ)do local cf=cY(cG)if type(cF)=='number'then table.insert(c_,e('[%s]=%s',cF,cf))else table.insert(c_,e('%s=%s',cF,cf))end end end;return e('{%s}',table.concat(c_,','))end;if cO(cZ)then return e("'%s'",cZ:gsub("'",[[\']]))end;return tostring(cZ)end;local d1={}d1.__index=d1;d1.__tostring=function(cZ,d2)local d3={}for cF in pairs(cZ)do table.insert(d3,cF)end;table.sort(d3)local c_={}for _,cF in ipairs(d3)do local cf=cY(cZ[cF])if type(cF)=='number'then table.insert(c_,e('[%s]=%s',cF,cf))else table.insert(c_,e('%s=%s',cF,cf))end end;if d2 then return e('%s%s',d2,table.concat(c_,',\n'..d2))end;return e('{%s}',table.concat(c_,','))end;d1.__eq=function(d4,d5)return d4.planetarySystemId==d5.planetarySystemId and d4.bodyId==d5.bodyId and ci(d4.radius,d5.radius)and ci(d4.center.x,d5.center.x)and ci(d4.center.y,d5.center.y)and ci(d4.center.z,d5.center.z)and ci(d4.GM,d5.GM)end;local function d6(d7,d8,d9,da,db)assert(cL(d7),'Argument 1 (planetarySystemId) must be a number:'..type(d7))assert(cL(d8),'Argument 2 (bodyId) must be a number:'..type(d8))assert(cL(d9),'Argument 3 (radius) must be a number:'..type(d9))assert(cM(da),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(da))assert(cL(db),'Argument 5 (GM) must be a number:'..type(db))return setmetatable({planetarySystemId=y(d7),bodyId=y(d8),radius=y(d9),center=vec3(da),GM=y(db)},d1)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(p)return e('::pos{%d,%d,%s,%s,%s}',p.systemId,p.bodyId,cW(p.latitude*cU),cW(p.longitude*cU),cW(p.altitude))end;MapPosition.__eq=function(d4,d5)return d4.bodyId==d5.bodyId and d4.systemId==d5.systemId and ci(d4.latitude,d5.latitude)and ci(d4.altitude,d5.altitude)and(ci(d4.longitude,d5.longitude)or ci(d4.latitude,math.pi/2)or ci(d4.latitude,-math.pi/2))end;local function dc(dd,d8,de,df,dg)local d7=dd;if cO(dd)and not df and not dg and not d8 and not de then d7,d8,de,df,dg=n(dd,cV)assert(d7,'Argument 1 (position string) is malformed.')else assert(cL(d7),'Argument 1 (systemId) must be a number:'..type(d7))assert(cL(d8),'Argument 2 (bodyId) must be a number:'..type(d8))assert(cL(de),'Argument 3 (latitude) must be in degrees:'..type(de))assert(cL(df),'Argument 4 (longitude) must be in degrees:'..type(df))assert(cL(dg),'Argument 5 (altitude) must be in meters:'..type(dg))end;d7=y(d7)d8=y(d8)de=y(de)df=y(df)dg=y(dg)if d8==0 then return setmetatable({latitude=de,longitude=df,altitude=dg,bodyId=d8,systemId=d7},MapPosition)end;return setmetatable({latitude=cT*q(de,-90,90),longitude=cT*(df%360),altitude=dg,bodyId=d8,systemId=d7},MapPosition)end;local dh={}dh.__index=dh;dh.__tostring=function(cZ,d2)local di=d2 and d2 ..'  'local dj={}local d3={}for cF in pairs(cZ)do table.insert(d3,cF)end;table.sort(d3)for _,dk in ipairs(d3)do bdy=cZ[dk]local dl=d1.__tostring(bdy,di)if d2 then table.insert(dj,e('[%s]={\n%s\n%s}',dk,dl,d2))else table.insert(dj,e('  [%s]=%s',dk,dl))end end;if d2 then return e('\n%s%s%s',d2,table.concat(dj,',\n'..d2),d2)end;return e('{\n%s\n}',table.concat(dj,',\n'))end;local function dm(dn)local aN={}local pid;for _,cG in pairs(dn)do local dp=cG.planetarySystemId;if type(dp)~='number'then error('Invalid planetary system ID: '..tostring(dp))elseif pid and dp~=pid then error('Mistringmatch planetary system IDs: '..dp..' and '..pid)end;local dq=cG.bodyId;if type(dq)~='number'then error('Invalid body ID: '..tostring(dq))elseif aN[dq]then error('Duplicate body ID: '..tostring(dq))end;setmetatable(cG.center,getmetatable(vec3.unit_x))aN[dq]=setmetatable(cG,d1)pid=dp end;return setmetatable(aN,dh)end;aR={}local function dr(dn)return setmetatable({galaxyAtlas=dn or{}},aR)end;aR.__index=function(cN,i)if type(i)=='number'then local system=cN.galaxyAtlas[i]return dm(system)end;return rawget(aR,i)end;aR.__pairs=function(cZ)return function(cN,cF)local ds,nv=next(cN,cF)return ds,nv and dm(nv)end,cZ.galaxyAtlas,nil end;aR.__tostring=function(cZ)local dt={}for _,du in pairs(cZ or{})do local dv=du:getPlanetarySystemId()local dw=dh.__tostring(du,'    ')table.insert(dt,e('  [%s]={%s\n  }',dv,dw))end;return e('{\n%s\n}\n',table.concat(dt,',\n'))end;aR.BodyParameters=d6;aR.MapPosition=dc;aR.PlanetarySystem=dm;function aR.createBodyParameters(dx,d8,dy,dz,dA,dB,dC)assert(cL(dx),'Argument 1 (planetarySystemId) must be a number:'..type(dx))assert(cL(d8),'Argument 2 (bodyId) must be a number:'..type(d8))assert(cL(dy),'Argument 3 (surfaceArea) must be a number:'..type(dy))assert(cM(dz),'Argument 4 (aPosition) must be an array or vec3:'..type(dz))assert(cM(dA),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(dA))assert(cL(dB),'Argument 6 (altitude) must be in meters:'..type(dB))assert(cL(dC),'Argument 7 (gravityAtPosition) must be number:'..type(dC))local d9=x(dy/4/math.pi)local aj=d9+dB;local dD=vec3(dz)+aj*vec3(dA)local db=dC*aj*aj;return d6(dx,d8,d9,dD,db)end;aR.isMapPosition=cR;function aR:getPlanetarySystem(dd)if i==nil then i=0 end;if nv==nil then nv=0 end;local dx=dd;if cR(dd)then dx=dd.systemId end;if type(dx)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=dh then system=dm(system)end;return system end end end;function dh:sizeCalculator(bU)return 1.05*bU.radius end;function dh:castIntersections(dE,dF,dG,dH,dI,dJ)local dK={}local dL=dI or self;for _,bU in pairs(dL)do table.insert(dK,bU)end;if not dJ then table.sort(dK,function(dM,dN)return(dM.center-dE):len()<(dN.center-dE):len()end)end;local dO=dF:normalize()for _,bU in ipairs(dK)do local dP=bU.center-dE;local d9=self:sizeCalculator(bU)local dQ=dP:dot(dO)local dR=dQ^2-(dP:len2()-d9^2)if dR>=0 then local dS=x(dR)local bS=dQ+dS;local bT=dQ-dS;if bT>0 then return bU,bS,bT elseif bS>0 then return bU,bS,nil end end end;return nil,nil,nil end;function dh:closestBody(dT)assert(type(dT)=='table','Invalid coordinates.')local dU,bU;local dV=vec3(dT)for _,dW in pairs(self)do local dX=(dW.center-dV):len2()if(not bU or dX<dU)and dW.name~="Space"then bU=dW;dU=dX end end;return bU end;function dh:convertToBodyIdAndWorldCoordinates(dd)local dY=dd;if cO(dd)then dY=dc(dd)end;if dY.bodyId==0 then return 0,vec3(dY.latitude,dY.longitude,dY.altitude)end;local dW=self:getBodyParameters(dY)if dW then return dY.bodyId,dW:convertToWorldCoordinates(dY)end end;function dh:getBodyParameters(dd)local d8=dd;if cR(dd)then d8=dd.bodyId end;assert(cL(d8),'Argument 1 (bodyId) must be a number:'..type(d8))return self[d8]end;function dh:getPlanetarySystemId()local _,cG=next(self)return cG and cG.planetarySystemId end;function d1:convertToMapPosition(da)assert(cM(da),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(da))local dZ=vec3(da)if self.bodyId==0 then return setmetatable({latitude=dZ.x,longitude=dZ.y,altitude=dZ.z,bodyId=0,systemId=self.planetarySystemId},MapPosition)end;local d_=dZ-self.center;local aj=d_:len()local dg=aj-self.radius;local de=0;local df=0;if not ci(aj,0)then local e0=m(d_.y,d_.x)df=e0>=0 and e0 or 2*math.pi+e0;de=math.pi/2-math.acos(d_.z/aj)end;return setmetatable({latitude=de,longitude=df,altitude=dg,bodyId=self.bodyId,systemId=self.planetarySystemId},MapPosition)end;function d1:convertToWorldCoordinates(dd)local dY=cO(dd)and dc(dd)or dd;if dY.bodyId==0 then return vec3(dY.latitude,dY.longitude,dY.altitude)end;assert(cR(dY),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(dY.systemId==self.planetarySystemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(dY.bodyId==self.bodyId,'Argument 1 (mapPosition) has a different planetary body ID.')local e1=math.cos(dY.latitude)return self.center+(self.radius+dY.altitude)*vec3(e1*math.cos(dY.longitude),e1*math.sin(dY.longitude),math.sin(dY.latitude))end;function d1:getAltitude(da)return(vec3(da)-self.center):len()-self.radius end;function d1:getDistance(da)return(vec3(da)-self.center):len()end;function d1:getGravity(da)local e2=self.center-vec3(da)local e3=e2:len2()return self.GM/e3*e2/x(e3)end;return setmetatable(aR,{__call=function(_,...)return dr(...)end})end;local function e4()local aT={}local e5=30000000/3600;local e6=e5*e5;local e7=100;function aT.computeAccelerationTime(e8,e9,ea)local eb=e5*math.asin(e8/e5)return(e5*math.asin(ea/e5)-eb)/e9 end;function aT.computeDistanceAndTime(e8,ea,ec,ed,ee,ef)ee=ee or 0;ef=ef or 0;local eg=e8<=ea;local eh=ed*(eg and 1 or-1)/ec;local ei=-ef/ec;local ej=eh+ei;if eg and ej<=0 or not eg and ej>=0 then return-1,-1 end;local ek,el=0,0;if eh~=0 and ee>0 then local eb=math.asin(e8/e5)local em=math.pi*(eh/2+ei)local en=eh*ee;local eo=e5*math.pi;local cG=function(cN)local ep=(em*cN-en*math.sin(math.pi*cN/2/ee)+eo*eb)/eo;local eq=math.tan(ep)return e5*eq/x(eq*eq+1)end;local er=eg and function(cP)return cP>=ea end or function(cP)return cP<=ea end;el=2*ee;if er(cG(el))then local es=0;while c(el-es)>0.5 do local cN=(el+es)/2;if er(cG(cN))then el=cN else es=cN end end end;local et=e8;local eu=el/e7;for ev=1,e7 do local ew=cG(ev*eu)ek=ek+(ew+et)*eu/2;et=ew end;if el<2*ee then return ek,el end;e8=et end;local eb=e5*math.asin(e8/e5)local D=(e5*math.asin(ea/e5)-eb)/ej;local ex=e6*math.cos(eb/e5)/ej;local aj=ex-e6*math.cos((ej*D+eb)/e5)/ej;return aj+ek,D+el end;function aT.computeTravelTime(e8,e9,aj)if aj==0 then return 0 end;if e9>0 then local eb=e5*math.asin(e8/e5)local ex=e6*math.cos(eb/e5)/e9;return(e5*math.acos(e9*(ex-aj)/e6)-eb)/e9 end;if e8==0 then return-1 end;assert(e8>0,'Acceleration and initial speed are both zero.')return aj/e8 end;return aT end;local function ey()local vec3=require('cpml.vec3')local cI=cI()local function cO(cP)return type(cP)=='string'end;local function cM(cN)return type(cN)=='table'end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(dg)assert(self.body)local aj=dg+self.body.radius;if not ci(aj,0)then local orbit=x(self.body.GM/aj)return x(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(dd,ez)assert(self.body)assert(cM(dd)or cO(dd))assert(cM(ez))local eA=(cO(dd)or cI.isMapPosition(dd))and self.body:convertToWorldCoordinates(dd)or vec3(dd)local cG=vec3(ez)local eB=eA-self.body.center;local eC=cG:len2()local eD=eB:len()local eE=self.body.GM;local eF=((eC-eE/eD)*eB-eB:dot(cG)*cG)/eE;local cj=eE/(2*eE/eD-eC)local eG=eF:len()local dO=eF:normalize()local eH=cj*(1-eG)local eI=cj*(1+eG)local eJ=eH*dO+self.body.center;local eK=eG<=1 and-eI*dO+self.body.center or nil;local eL=x(cj*eE*(1-eG*eG))local eM=eK and 2*math.pi*x(cj^3/eE)local eN=math.acos(eF:dot(eB)/(eG*eD))if eB:dot(cG)<0 then eN=-(eN-2*math.pi)end;local eO=math.acos((math.cos(eN)+eG)/(1+eG*math.cos(eN)))local eP=eO;if eP<0 then eP=eP+2*math.pi end;local eQ=eP-eG*math.sin(eP)local eR=0;local eS=0;local eT=0;if eM~=nil then eR=eQ/(2*math.pi/eM)eS=eM-eR;eT=eS+eM/2;if eN-math.pi>0 then eS=eR;eT=eS+eM/2 end;if eT>eM then eT=eT-eM end end;return{periapsis={position=eJ,speed=eL/eH,circularOrbitSpeed=x(eE/eH),altitude=eH-self.body.radius},apoapsis=eK and{position=eK,speed=eL/eI,circularOrbitSpeed=x(eE/eI),altitude=eI-self.body.radius},currentVelocity=cG,currentPosition=eA,eccentricity=eG,period=eM,eccentricAnomaly=eO,meanAnomaly=eQ,timeToPeriapsis=eS,timeToApoapsis=eT}end;local function eU(eV)local dW=cI.BodyParameters(eV.planetarySystemId,eV.bodyId,eV.radius,eV.center,eV.GM)return setmetatable({body=dW},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return eU(...)end})end;local function eW()local eX={}local eY={}local eZ={XS=13,S=27,M=55,L=110,XL=221}local e_={}local f0;local f1;local f2;local f3;local f4;local function f5()local function f6(f7,f8,f9,fa,fb,fc,fd,fe)f8,fa,fc,fe=vec3(f8),vec3(fa),vec3(fc),vec3(fe)local ff,fg,fh=f7*f7,f9*f9,fb*fb;local eC=fa-f8;local fi=eC:normalize()local fj=eC:len()local fk=fc-f8;local fl=(fk-fk:project_on(fi)):normalize()local fm,fn=fk:dot(fi),fk:dot(fl)local fo=fm*fm+fn*fn;local fp=fi:cross(fl)local c9=(ff-fg+fj*fj)/(2*fj)local ca=(ff-fh+fo-2*fm*c9)/(2*fn)local cS=ff-c9^2-ca^2;local fq=x(cS)local fr=f8+fi*c9+fl*ca+fp*fq;local fs=f8+fi*c9+fl*ca-fp*fq;if c((fe-fr):len()-fd)<c((fe-fs):len()-fd)then return fr else return fs end end;local function ft()local function fu()local fv=core.getConstructWorldOrientationRight()local eC=core.getConstructWorldOrientationForward()local fk=core.getConstructWorldOrientationUp()local fw=library.systemResolution3(fv,eC,fk,{1,0,0})local fx=library.systemResolution3(fv,eC,fk,{0,1,0})local fy=library.systemResolution3(fv,eC,fk,{0,0,1})return function(fz)return library.systemResolution3(fw,fx,fy,fz)end end;local fA=fu()local fB=core.getConstructWorldPos()local eA=core.getElementPositionById(1)local fC={eA[1]-F,eA[2]-F,eA[3]-F}local fD=fA(fC)local fE={fB[1]-fD[1],fB[2]-fD[2],fB[3]-fD[3]}return fE end;local function fF(fG,eD,fH)local fI=fG.pts;local fJ=#fI;local fK=fG.ref;if fJ>3 then local fL,fM,fN,fO=fI[fJ],fI[fJ-1],fI[fJ-2],fI[fJ-3]fG.ref=fH;local eA=f6(fL[1],fL[2],fM[1],fM[2],fN[1],fN[2],fO[1],fO[2])local c9,ca,fq=eA.x,eA.y,eA.z;if c9==c9 and ca==ca and fq==fq then c9=c9+fK[1]ca=ca+fK[2]fq=fq+fK[3]local fP=vec3(c9,ca,fq)if not fG.lastPos then fG.center=fP elseif(fG.lastPos-fP):len()<2 then fG.center=fP;fG.skipCalc=true end;fG.lastPos=fP end;fG.pts={}else local fQ={fH[1]-fK[1],fH[2]-fK[2],fH[3]-fK[3]}fI[fJ+1]={eD,fQ}end end;if radar_1 then f0=#radar_1.getEntries()local fR=radar_1.getData()local fS=fR:gmatch('{"constructId[^}]*}[^}]*}')if f0>0 then local fH=ft()local fT,fU=0,0;f4,f3=0,0;for cG in fS do local dp,aj,fV=cG:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local fW=eZ[fV]aj=y(aj)if radar_1.hasMatchingTransponder(dp)==1 then table.insert(eY,dp)end;local fX=radar_1.getConstructType(dp)if CollisionSystem then if fW>27 or fX=="static"or fX=="space"then f4=f4+1;local fY=radar_1.getConstructName(dp)local fG=bL[dp]if fG==nil then fW=fW+G;bL[dp]={pts={},ref=fH,name=fY,i=0,radius=fW,skipCalc=false}fG=bL[dp]end;if not fG.skipCalc then fF(fG,aj,fH)fU=fU+1 end;if fG.center then table.insert(e_,fG)end end;fT=fT+1;if bM and fT>700 or fU>70 or(not bM and fT>300 or fU>30)then coroutine.yield()fT,fU=0,0 end end end;f3=#e_;if f3>0 and bt>20 then local bU,fZ,f_,g0;local g1=0;local g2=aS:getPlanetarySystem(0)g0=bs:normalize()while g1<f3 do coroutine.yield()local g3={table.unpack(e_,g1,math.min(g1+75,f3))}bU,fZ,f_=g2:castIntersections(bw,g0,nil,nil,g3,true)if bU and f_ then bO={bU,fZ,f_}break end;g1=g1+75 end;if not bU then bO=nil end else bO=nil end;e_={}f1=fR:find('identifiedConstructs":%[%]')else f2=fR:find('worksInEnvironment":false')end end end;function eX.UpdateRadar()local g4=coroutine.status(UpdateRadarCoroutine)if g4=="suspended"then local cf,g5=coroutine.resume(UpdateRadarCoroutine)if g5 then system.print("ERROR UPDATE RADAR: "..g5)end elseif g4=="dead"then UpdateRadarCoroutine=coroutine.create(f5)local cf,g5=coroutine.resume(UpdateRadarCoroutine)end end;function eX.GetRadarHud()local g6=eY;eY={}return f1,f2,f0,f3,f4,g6 end;UpdateRadarCoroutine=coroutine.create(f5)return eX end;local function g7()local g8=0;local g9=9.80665;local ga=vec3({13771471,7435803,-128971})local gb=18000000;local gc=500000;local gd,ge=math.huge;local gf;local function gg(gh)gd=vec3(gh):dist(ga)if gd<gb then return true,c(gd-gb)end;ge=vec3(gh):dist(vec3(planet.center))if ge<gc then gf=true else gf=false end;if c(ge-gc)<c(gd-gb)then return gf,c(ge-gc)else return gf,c(gd-gb)end end;local function gi(cG)if aG==1920 then return cG else return z(aG*cG/1920,0)end end;local function gj(cG)if aH==1080 then return cG else return z(aH*cG/1080,0)end end;local function gk()return w()==0 and userControlScheme~="keyboard"and l()==0 end;local function gl()local gm="TRAVEL"if not bB then gm="CRUISE"end;if Autopilot then gm="AUTOPILOT"end;return gm end;local gn=""local go=""local gp=""local gq=1;local gr=2;local gs=3;local gt=4;local gu=5;local gv=6;local gw=""local gx=0;local gy=d(1/apTickRate)*2*hudTickRate;local gz={}local gA={}local gB={}local gC={}local gD={}local gE={}local function gF(c9,gG,gH,gI,gJ,gK)local gL=fuelY;local gM=fuelY+5;if not BarFuelDisplay then gM=gM+5 end;if l()==1 and not RemoteHud then gL=gL-50;gM=gM-50 end;if gH=="ATMO"then gw="atmofueltank"elseif gH=="SPACE"then gw="spacefueltank"else gw="rocketfueltank"end;gx=_G[gw.."_size"]if#gI>0 then for i=1,#gI do local fY=string.sub(gI[i][gr],1,12)local gN=0;for gO=1,gx do if gI[i][gr]==f(unit[gw.."_"..gO].getData()).name then gN=gO;break end end;local gP=o()if gJ[i]==nil or gK[i]==nil or gP-gI[i][gv]>gy then local gQ;local gR=0;if gN~=0 then gK[i]=f(unit[gw.."_"..gN].getData()).percentage;gJ[i]=f(unit[gw.."_"..gN].getData()).timeLeft;if gJ[i]=="n/a"then gJ[i]=0 end else gR=k(gI[i][gq])-gI[i][gt]gK[i]=d(0.5+gR*100/gI[i][gs])gQ=gI[i][gu]if gQ<=gR then gJ[i]=0 else gJ[i]=d(0.5+gR/((gQ-gR)/(gP-gI[i][gv])))end;gI[i][gu]=gR;gI[i][gv]=gP end end;if fY==gG then fY=e("%s %d",gH,i)end;if gN==0 then fY=fY.." *"end;local gS;if gJ[i]==0 then gS=""else gS=cw(gJ[i])end;if gK[i]~=nil then local gT=d(gK[i]*2.55)local gU=e("rgb(%d,%d,%d)",255-gT,gT,0)local cc=""if gS~=""and gJ[i]<120 or gK[i]<5 then cc="red "end;if BarFuelDisplay then go=go..e([[
                                            <g class="pdim">                        
                                            <rect fill=grey class="bar" x="%d" y="%d" width="100" height="13"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                                            <text fill=black x="%d" y="%d">%s%% %s</text>
                                            </g>]],c9,gM,gU,gK[i],c9,gM,c9+2,gM+10,gK[i],gS)go=go..c8(c9,gL,fY,cc.."txtstart pdim txtfuel")gL=gL-30;gM=gM-30 else go=go..c8(c9,gL,fY,cc.."pdim txtfuel")go=go..c8(c9,gM,e("%d%% %s",gK[i],gS),"pdim txtfuel","fill:"..gU)gL=gL+30;gM=gM+30 end end end end end;local function gV(gW,dg)if dg<200000 and not aq or dg and aq then local gX=0;if c(bv)>1 then gX=45*math.log(c(bv),10)if bv<0 then gX=-gX end end;gW[#gW+1]=e([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,d(bv),d(gX))end;return gW end;local function gY(gZ)local g_=-bu;gZ=gZ-gZ:project_on(g_)local h0=vec3(0,0,1)h0=h0-h0:project_on(g_)local h1=h0:cross(g_)local gX=h0:angle_between(gZ)*constants.rad2deg;if gZ:dot(h1)<0 then gX=360-gX end;return gX end;local function h2(gW,centerX,centerY,h3,h4,bM)local h5=circleRad;local h6=20;local h7=d(h3)if bM then for i=-45,45,5 do local h8=i;gW[#gW+1]=e([[<g transform="rotate(%f,%d,%d)">]],h8,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;gW[#gW+1]=e([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+h5+h6-len,centerX,centerY+h5+h6)end;gW[#gW+1]=c8(centerX,centerY+h5+h6-35,h4,"pdim txt txtmid")gW[#gW+1]=c8(centerX,centerY+h5+h6-25,h7 .." deg","pdim txt txtmid")gW[#gW+1]=e([[<g transform="rotate(%f,%d,%d)">]],-h3,centerX,centerY)gW[#gW+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+h5+h6-20,centerX+5,centerY+h5+h6-20,centerX,centerY+h5+h6-15)gW[#gW+1]="</g>"end;local h9=h7;if bM then h9=gY(bp)end;local ha=20;local hb=d(h9)local hc=0;local hd=centerY+h5+h6+20;local he=centerX;if h4~="YAW"then hd=gj(130)he=gi(960)end;local hf=[[<path class="txttick line" d="]]local hg=d(hb-(ha+10)-hb%5+0.5)for i=hg+60,hg,-5 do local c9=he-(-i*5+h9*5)if i%10==0 then hc=10;local A=i;if A==360 then A=0 elseif A>360 then A=A-360 elseif A<0 then A=A+360 end;gW[#gW+1]=c8(c9+5,hd-12,A)elseif i%5==0 then hc=5 end;if hc==10 then hf=e([[%s M %f %f v %d]],hf,c9,hd-5,hc)else hf=e([[%s M %f %f v %d]],hf,c9,hd-2.5,hc)end end;gW[#gW+1]=hf..[["/>]]gW[#gW+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/>]],he-5,hd+10,he+5,hd+10,he,hd+5)if bM then h4="HDG"end;gW[#gW+1]=c8(he,hd+25,hb.."deg","pdim txt txtmid","")gW[#gW+1]=c8(he,hd+35,h4,"pdim txt txtmid","")end;local function hh(gW,hi,h3,centerX,centerY,bM,hj,ew)local h5=circleRad;local hk=d(h5*3/5)if h5>0 then local hl=d(hi)local len=0;local hf=e([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*h3,centerX,centerY)if not aq then hf=e([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;gW[#gW+1]=e([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],h5-1,centerX,centerY)gW[#gW+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=d(hl-30-hl%5+0.5),d(hl+30+hl%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local ca=centerY+-i*5+hi*5;if len==30 then hf=e([[%s M %d %f h %d]],hf,centerX-hk-len,ca,len)if aq then gW[#gW+1]=e([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*h3,centerX,centerY,centerX-hk+10,ca,i)gW[#gW+1]=e([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*h3,centerX,centerY,centerX+hk-10,ca,i)if i==0 or i==180 or i==-180 then gW[#gW+1]=e([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*h3,centerX,centerY,centerX-hk+20,ca,hk*2-40)end else gW[#gW+1]=c8(centerX-hk+10,ca,i,"pdim txt txtmid")gW[#gW+1]=c8(centerX+hk-10,ca,i,"pdim txt txtmid")end;hf=e([[%s M %d %f h %d]],hf,centerX+hk,ca,len)else hf=e([[%s M %d %f h %d]],hf,centerX-hk-len,ca,len)hf=e([[%s M %d %f h %d]],hf,centerX+hk,ca,len)end end;gW[#gW+1]=hf..[["/>]]local hm="PITCH"if not bM then hm="REL PITCH"end;if hi>90 and not aq then hi=90-(hi-90)elseif hi<-90 and not aq then hi=-90-(hi+90)end;if h5>200 then if aq then if ew>Q then gW[#gW+1]=c8(centerX,centerY-15,"Yaw","pdim txt txtmid")gW[#gW+1]=c8(centerX,centerY+20,hj,"pdim txt txtmid")end;gW[#gW+1]=e([[<g transform="rotate(%f,%d,%d)">]],-h3,centerX,centerY)else gW[#gW+1]=e([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;gW[#gW+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-hk+25,centerY-5,centerX-hk+20,centerY,centerX-hk+25,centerY+5,centerX-hk+50,centerY+4,hl)gW[#gW+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+hk-25,centerY-5,centerX+hk-20,centerY,centerX+hk-25,centerY+5,centerX+hk-30,centerY+4,hl)gW[#gW+1]="</g>"end;local hn=d(h5/3)gW[#gW+1]=e([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-hn,centerY,h5-hn)if not aq and bM then gW[#gW+1]=e([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*h3,centerX,centerY,centerX-hk+10,centerY,hk*2-20)end;gW[#gW+1]="</g>"if h5<200 then if aq and ew>Q then gW[#gW+1]=c8(centerX,centerY-h5,hm,"pdim txt txtmid")gW[#gW+1]=c8(centerX,centerY-h5+10,hl,"pdim txt txtmid")gW[#gW+1]=c8(centerX,centerY-15,"Yaw","pdim txt txtmid")gW[#gW+1]=c8(centerX,centerY+20,hj,"pdim txt txtmid")else gW[#gW+1]=c8(centerX,centerY-h5,hm,"pdim txt txtmid")gW[#gW+1]=c8(centerX,centerY-h5+15,hl,"pdim txt txtmid")end end end end;local function ho(gW,dg,bM)local hp=altMeterX;local hq=altMeterY;local hr=78;local hs=19;local ht=ao;if ao~=-1 then gW[#gW+1]=c8(hp+hr,hq+hs+20,e("AGL: %.1fm",ao),"pdim altsm txtend")end;if bM and(dg<200000 and not aq or dg and aq)then table.insert(gW,e([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],hp-1,hq-4,hr+2,hs+6,hp+1,hq-1,hr-4,hs))local fJ=0;local hu=1;local hv=0;local hw=dg<0;local hx=dg<planet.surfaceMaxAltitude;local hy=9;if hw then hy=0 end;local dg=c(dg)while fJ<6 do local hz=11;local hA=16;local hB=9;local hC=14;local cc="altsm"if fJ>2 then hA=hA+3;hz=hz+2;hC=hC+2;hB=hB-6;cc="altbig"end;if hw then cc=cc.." red"elseif hx then cc=cc.." orange"end;local hD=dg/hu%10;local hE=d(hD)local hF=d((hE+1)%10)local hG=hv;if fJ==0 then hG=hD-hE;if hw then hG=1-hG end end;if hw and(fJ==0 or hv~=0)then local hH=hF;hF=hE;hE=hH end;local hI=hA*(hG-1)local hJ=hI+hA;local c9=hp+hB+(6-fJ)*hz;local ca=hq+hC;gW[#gW+1]=c8(c9,ca+hI,hF,cc)gW[#gW+1]=c8(c9,ca+hJ,hE,cc)fJ=fJ+1;hu=hu*10;if hE==hy then hv=hG else hv=0 end end;table.insert(gW,[[</g></g>]])end end;local function hK(ez)local hL=-math.deg(m(ez.y,ez.z))+180;hL=hL-90;if hL<0 then hL=360+hL end;if hL>180 then hL=-180+hL-180 end;return-hL end;local function hM(ez)local h9=math.deg(m(ez.y,ez.x))-90;if h9<-180 then h9=360+h9 end;return h9 end;local function hN(gW,ez,ew,centerX,centerY)if ew>5 and not aq or ew>Q then local h5=circleRad;local hO=20;local hP=20;local hQ=hK(ez)local hR=hM(ez)local hS=14;local hT=hS/2;local hU=-hR/hP*h5;local hV=hQ/hO*h5;local c9=centerX+hU;local ca=centerY+hV;local aj=x(hU^2+hV^2)local hW=[[<circle
                            cx="]]..c9 ..[["
                            cy="]]..ca..[["
                            r="]]..hT/hS..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..c9 ..[["
                            cy="]]..ca..[["
                            r="]]..hT..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..c9-hS..[[,]]..ca..[[ h ]]..hT..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..c9+hT..[[,]]..ca..[[ h ]]..hT..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..c9 ..[[,]]..ca-hS..[[ v ]]..hT..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if aj<h5 then gW[#gW+1]=hW else local gX=m(hV,hU)local hX=4;local hY=centerX+h5*math.cos(gX)local hZ=centerY+h5*math.sin(gX)gW[#gW+1]=e('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',gX*180/math.pi,hY,hZ,hY-hX,hZ-hX/2,hX*2,hX,hY+hX,hZ-hX,hX,hX,-hX,hX)end;if not aq then local h_=vec3(ez)hQ=hK(-h_)hR=hM(-h_)hU=-hR/hP*h5;hV=hQ/hO*h5;c9=centerX+hU;ca=centerY+hV;aj=x(hU^2+hV^2)if aj<h5 then local i0=[[<circle
                                    cx="]]..c9 ..[["
                                    cy="]]..ca..[["
                                    r="]]..hT..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..c9 ..[[,]]..ca-hS..[[ v ]]..hT..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..c9 ..[[,]]..ca..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..c9 ..[[,]]..ca..[[)" />
                                <path
                                    d="M ]]..c9-hT..[[,]]..ca..[[ h ]]..hS..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..c9 ..[[,]]..ca..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..c9 ..[[,]]..ca..[[)"/>]]gW[#gW+1]=i0 end end end end;local function i1(gW,gm,i2,i3)i2=d(i2+0.5)local gL=throtPosY+10;local gM=throtPosY+20;if l()==1 and not RemoteHud then gL=55;gM=65 end;local i4="CRUISE"local unit="km/h"local cf=i3;if gm=="TRAVEL"or gm=="AUTOPILOT"then i4="THROT"unit="%"cf=i2;local i5="dim"if i2<0 then i5="red"end;gW[#gW+1]=e([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],i5,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-c(i2),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;gW[#gW+1]=c8(throtPosX+10,gL,i4,"pbright txtstart")gW[#gW+1]=c8(throtPosX+10,gM,e("%.0f %s",cf,unit),"pbright txtstart")if aq and AtmoSpeedAssist and bB and M then i2=d(N*100+0.5)local i5="red"if i2<0 then i5="red"end;gW[#gW+1]=e([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],i5,1-c(i2),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)gW[#gW+1]=c8(throtPosX+10,gL+40,"LIMIT","pbright txtstart")gW[#gW+1]=c8(throtPosX+10,gM+40,i2 .."%","pbright txtstart")end;if aq and AtmoSpeedAssist or Reentry then gW[#gW+1]=c8(throtPosX+10,gL-40,"LIMIT: "..b8 .." km/h","dim txtstart")elseif not aq and Autopilot then gW[#gW+1]=c8(throtPosX+10,gL-40,"LIMIT: "..d(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function i6(gW,i7)local i8=throtPosY-10;local i9=throtPosX+10;gW[#gW+1]=c8(0,0,"","pdim txt txtend")if l()==1 and not RemoteHud then i8=75 end;gW[#gW+1]=c8(i9,i8,d(i7).." km/h","pbright txtbig txtstart")end;local function ia(gW)gW[#gW+1]=c8(gi(1900),gj(1070),e("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")gW[#gW+1]=[[<g class="warnings">]]if unit.isMouseControlActivated()==1 then gW[#gW+1]=c8(gi(960),gj(550),"Warning: Invalid Control Scheme Detected","warnings")gW[#gW+1]=c8(gi(960),gj(600),"Keyboard Scheme must be selected","warnings")gW[#gW+1]=c8(gi(960),gj(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local ib=gi(960)local ic=gj(860)local id=gj(880)local ie=gj(900)local ig=gj(960)local ih=gj(200)local ii=gj(250)local ij=gj(960)if l()==1 and not RemoteHud then ic=gj(135)id=gj(155)ie=gj(175)ih=gj(115)ii=gj(95)end;if BrakeIsOn then gW[#gW+1]=c8(ib,ic,"Brake Engaged","warnings")elseif L>0 then gW[#gW+1]=c8(ib,ic,"Auto-Brake Engaged","warnings","opacity:"..L)end;if aq and b3 and ao==-1 then if not Autopilot and not VectorToTarget and not BrakeLanding and not bz and not VertTakeOff and not AutoTakeoff then gW[#gW+1]=c8(ib,ih+50,"** STALL WARNING **","warnings")bW("stall","SW",2)end end;if bK then gW[#gW+1]=c8(ib,ih+90,"Flight Assist in Progress","warnings")end;if ax then gW[#gW+1]=c8(ib,ij,"Gyro Enabled","warnings")end;if GearExtended then if S then gW[#gW+1]=c8(ib,id,"Gear Extended","warn")else gW[#gW+1]=c8(ib,id,"Landed (G: Takeoff)","warnings")end;local ik=cl(a:getTargetGroundAltitude())gW[#gW+1]=c8(ib,ie,"Hover Height: "..ik,"warn")end;if a7 then gW[#gW+1]=c8(ib,ig+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not ExternalAGG and bz and AntigravTargetAltitude~=nil then if c(as-antigrav.getBaseAltitude())<501 then gW[#gW+1]=c8(ib,ih+15,e("AGG On - Target Altitude: %d Singularity Altitude: %d",d(AntigravTargetAltitude),d(antigrav.getBaseAltitude())),"warn")else gW[#gW+1]=c8(ib,ih+15,e("AGG On - Target Altitude: %d Singluarity Altitude: %d",d(AntigravTargetAltitude),d(antigrav.getBaseAltitude())),"warnings")end elseif Autopilot and AutopilotTargetName~="None"then gW[#gW+1]=c8(ib,ih+20,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then gW[#gW+1]=c8(ib,ih+20,e("LockedPitch: %d",d(LockPitch)),"warn")elseif a0 then gW[#gW+1]=c8(ib,ih+20,"Follow Mode Engaged","warn")elseif Reentry or an then gW[#gW+1]=c8(ib,ih+20,"Re-entry in Progress","warn")end;if AltitudeHold or VertTakeOff then local ik=cl(HoldAltitude,2)if VertTakeOff then if bz then ik=cl(antigrav.getBaseAltitude(),2).." AGG singularity height"end;gW[#gW+1]=c8(ib,ih,"VTO to "..ik,"warn")elseif AutoTakeoff and not IntoOrbit then if am then gW[#gW+1]=c8(ib,ih,"Takeoff to "..AutopilotTargetName,"warn")else gW[#gW+1]=c8(ib,ih,"Takeoff to "..ik,"warn")end;if BrakeIsOn and not VertTakeOff then gW[#gW+1]=c8(ib,ih+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else gW[#gW+1]=c8(ib,ih,"Altitude Hold: "..ik,"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if ar>0.1 then gW[#gW+1]=c8(ib,ih+20,"Beginning ascent","warn")elseif ar<0.09 and ar>0.05 then gW[#gW+1]=c8(ib,ih+20,"Aligning trajectory","warn")elseif ar<0.05 then gW[#gW+1]=c8(ib,ih+20,"Leaving atmosphere","warn")end end;if IntoOrbit then if ba~=nil then gW[#gW+1]=c8(ib,ih,ba,"warn")end end;if BrakeLanding then if StrongBrakes then gW[#gW+1]=c8(ib,ih,"Brake-Landing","warnings")else gW[#gW+1]=c8(ib,ih,"Coast-Landing","warnings")end end;if ProgradeIsOn then gW[#gW+1]=c8(ib,ih,"Prograde Alignment","crit")end;if RetrogradeIsOn then gW[#gW+1]=c8(ib,ih,"Retrograde Alignment","crit")end;if bN then local type;if string.find(bN,"COLLISION")then type="warnings"else type="crit"end;gW[#gW+1]=c8(ib,ii+20,bN,type)elseif ar==0 then local bR,bV=bP(bs:normalize())if bV~=nil then local ik=cl(bV)local travelTime=aT.computeTravelTime(bt,0,bV)local il="Collision"if bR.noAtmosphericDensityAltitude>0 then il="Atmosphere"end;gW[#gW+1]=c8(ib,ii+20,bR.name.." "..il.." "..cw(travelTime).." In "..ik,"crit")end end;if VectorToTarget and not IntoOrbit then gW[#gW+1]=c8(ib,ih+35,VectorStatus,"warn")end;gW[#gW+1]="</g>"return gW end;local function im(ew)return d(z(ew*3.6,0)+0.5).." km/h"end;local function io(gW)local ip=OrbitMapX;local iq=OrbitMapY;local ir=OrbitMapSize;local is=4;local it=15;local c9=0;local ca=0;local iu,iv,iw,ix;local function iy(type)local iz,D,ew,iA;if type=="Periapsis"then iz=orbit.periapsis.altitude;D=orbit.timeToPeriapsis;ew=orbit.periapsis.speed;iA=35 else iz=orbit.apoapsis.altitude;D=orbit.timeToApoapsis;ew=orbit.apoapsis.speed;iA=-35 end;gW[#gW+1]=e([[<line class="pdim op30 linethick" x1="%f" y1="%f" x2="%f" y2="%f"/>]],c9+iA,ca-5,ip+ir/2-iu+ix,ca-5)gW[#gW+1]=c8(c9,ca,type)ca=ca+it;local ik=cl(iz)gW[#gW+1]=c8(c9,ca,ik)ca=ca+it;gW[#gW+1]=c8(c9,ca,cw(D))ca=ca+it;gW[#gW+1]=c8(c9,ca,im(ew))end;if orbit~=nil and ar<0.2 and planet~=nil and orbit.apoapsis~=nil and orbit.periapsis~=nil and orbit.period~=nil and orbit.apoapsis.speed>5 and DisplayOrbit then iq=iq+is;c9=ip+ir+ip/2+is;ca=iq+ir/2+5+is;iu=ir/4;ix=0;gW[#gW+1]=[[<g class="pbright txtorb txtmid">]]gW[#gW+1]=e('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" style="fill:rgb(0,0,100);stroke-width:4;stroke:white;fill-opacity:0.3;" />',ir+ip*2,ir+iq,is,is)if orbit.periapsis~=nil and orbit.apoapsis~=nil then iw=(orbit.apoapsis.altitude+orbit.periapsis.altitude+planet.radius*2)/(iu*2)iv=(planet.radius+orbit.periapsis.altitude+(orbit.apoapsis.altitude-orbit.periapsis.altitude)/2)/iw*(1-orbit.eccentricity)ix=iu-orbit.periapsis.altitude/iw-planet.radius/iw;local iB=""if orbit.periapsis.altitude<=0 then iB='redout'end;gW[#gW+1]=e([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],iB,ip+ir/2+ix+is,iq+ir/2+is,iu,iv)gW[#gW+1]=e('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="3" fill="blue" />',ip+ir/2+is,iq+ir/2+is,planet.radius/iw)end;if orbit.apoapsis~=nil and orbit.apoapsis.speed<MaxGameVelocity and orbit.apoapsis.speed>1 then iy("Apoapsis")end;ca=iq+ir/2+5+is;c9=ip-ip/2+10+is;if orbit.periapsis~=nil and orbit.periapsis.speed<MaxGameVelocity and orbit.periapsis.speed>1 then iy("Periapsis")end;gW[#gW+1]=c8(ip+ir/2+is,planet.name,20+is,"txtorbbig")if orbit.period~=nil and orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.apoapsis.speed>1 then local iC=orbit.timeToApoapsis/orbit.period*2*math.pi;local iD=iu*math.cos(iC)local iE=iv*math.sin(iC)gW[#gW+1]=e('<circle cx="%f" cy="%f" r="5" stroke="white" stroke-width="3" fill="white" />',ip+ir/2+iD+ix+is,iq+ir/2+iE+is)end;gW[#gW+1]=[[</g>]]return gW else return gW end end;local function iF(iG,iH)local iI;local iJ=(iH-iG):normalize()local eB=(bw-iG):dot(iJ)/iJ:dot(iJ)if eB<=0.then return(bw-iG):len()elseif eB>=(iH-iG):len()then return(bw-iH):len()end;local iK=iG+eB*iJ;iI=(iK-bw):len()return iI end;local function iL()local iI;local iM=nil;local iN=nil;local iO=nil;for cF,iP in pairs(aN[0])do if iP.hasAtmosphere then local aj=iF(planet.center,iP.center)if iM==nil or aj<iM then iN=iP;iM=aj;iO=planet end;if ac and ac.hasAtmosphere and ac.name~=planet.name then local dX=iF(ac.center,iP.center)if dX<iM then iN=iP;iM=dX;iO=ac end end end end;local iQ=gi(1770)local iR=gj(330)if iM then local iS="txttick "local iT=500000;if iM<iN.radius+iT or iM<iO.radius+iT then if bI then iS="txttick red "else iS="txttick orange "end end;iI=cl(iM,2)bJ=c8(iQ,iR,"Pipe ("..iO.name.."--"..iN.name.."): "..iI,iS.."pbright txtmid")end end;local iU={}function iU.HUDPrologue(gW)bI,g8=gg(bw)if not bI then H=PvPR;J=PvPG;I=PvPB else H=SafeR;J=SafeG;I=SafeB end;ay=[[rgb(]]..d(H+0.5)..","..d(J+0.5)..","..d(I+0.5)..[[)]]az=[[rgb(]]..d(H*0.9+0.5)..","..d(J*0.9+0.5)..","..d(I*0.9+0.5)..[[)]]local iV=ay;local iW=az;local iX=ay;local iY=az;if gk()and not brightHud then iV=[[rgb(]]..d(H*0.4+0.5)..","..d(J*0.4+0.5)..","..d(I*0.3+0.5)..[[)]]iW=[[rgb(]]..d(H*0.3+0.5)..","..d(J*0.3+0.5)..","..d(I*0.2+0.5)..[[)]]end;gW[#gW+1]=e([[
                        <head>
                            <style>
                                body {margin: 0}
                                svg {position:absolute;top:0;left:0;font-family:Montserrat;} 
                                .txt {font-size:10px;font-weight:bold;}
                                .txttick {font-size:12px;font-weight:bold;}
                                .txtbig {font-size:14px;font-weight:bold;}
                                .altsm {font-size:16px;font-weight:normal;}
                                .altbig {font-size:21px;font-weight:normal;}
                                .line {stroke-width:2px;fill:none}
                                .linethick {stroke-width:3px;fill:none}
                                .warnings {font-size:26px;fill:red;text-anchor:middle;font-family:Bank}
                                .warn {fill:orange;font-size:24px}
                                .crit {fill:darkred;font-size:28px}
                                .bright {fill:%s;stroke:%s}
                                .pbright {fill:%s;stroke:%s}
                                .dim {fill:%s;stroke:%s}
                                .pdim {fill:%s;stroke:%s}
                                .red {fill:red;stroke:red}
                                .orange {fill:orange;stroke:orange}
                                .redout {fill:none;stroke:red}
                                .op30 {opacity:0.3}
                                .op10 {opacity:0.1}
                                .txtstart {text-anchor:start}
                                .txtend {text-anchor:end}
                                .txtmid {text-anchor:middle}
                                .txtvspd {font-family:sans-serif;font-weight:normal}
                                .txtvspdval {font-size:20px}
                                .txtfuel {font-size:11px;font-weight:bold}
                                .txtorb {font-size:12px}
                                .txtorbbig {font-size:18px}
                                .hudver {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}
                                .msg {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}
                                .cursor {stroke:white}
                            </style>
                        </head>
                        <body>
                            <svg height="100%%" width="100%%" viewBox="0 0 %d %d">
                            ]],iV,iV,iX,iX,iW,iW,iY,iY,aG,aH)return gW end;function iU.DrawVerticalSpeed(gW,dg)gV(gW,dg)end;function iU.UpdateHud(gW)local hL=bC;local iZ=bD;local h3=iZ;local hi=hL;local i2=d(unit.getThrottle())local i7=bt*3.6;local i3=unit.getAxisCommandValue(0)local i_=gi(1770)local j0=gj(310)if AtmoSpeedAssist and bB then i3=K;i2=K*100 end;local gm=gl()local h4="ROLL"if i2==nil then i2=0 end;if not bM then if bt>5 then hL=hK(br)iZ=hM(br)else hL=0;iZ=0 end;h4="YAW"end;if g8>50000 and not aq then local j1;j1=cl(g8)gW[#gW+1]=c8(i_,j0,"PvP Boundary: "..j1,"pbright txtbig txtmid")end;gW[#gW+1]=ak;gW[#gW+1]=aD;gW[#gW+1]=gn;if bJ~=""then gW[#gW+1]=bJ end;if go~=""then gW[#gW+1]=go end;if gp~=""then gW[#gW+1]=gp end;gV(gW,as)if l()==0 or RemoteHud then if not gk()or brightHud then if bM then h2(gW,centerX,centerY,h3,h4,bM)hh(gW,hi,h3,centerX,centerY,bM,d(hM(br)),bt)else h2(gW,centerX,centerY,iZ,h4,bM)hh(gW,hL,iZ,centerX,centerY,bM,d(iZ),bt)end;ho(gW,as,bM)hN(gW,br,bt,centerX,centerY)end end;i1(gW,gm,i2,i3)i6(gW,i7)ia(gW)io(gW)return gW end;function iU.HUDEpilogue(gW)gW[#gW+1]="</svg>"return gW end;function iU.ExtraData(gW)local j2=gi(1240)local j3=gj(55)local j4=j3+10;local j5;local j6=0;local gm=gl()if VertTakeOffEngine then gm=gm.."-VERTICAL"end;if CollisionSystem and not AutoTakeoff and not BrakeLanding and bt>20 then gm=gm.."-COLLISION ON"end;if UseExtra~="Off"then gm="("..UseExtra..")-"..gm end;if TurnBurn then gm="TB-"..gm end;if not stablized then gm=gm.."-DeCoupled"end;local j7=vec3(core.getWorldAcceleration()):len()/9.80665;j5=core.g()gW[#gW+1]=[[<g class="pdim txt txtend">]]if l()==1 and not RemoteHud then j2=gi(1120)j3=gj(55)j4=j3+10 elseif aq then local j8=gi(770)gW[#gW+1]=c8(j8,j3,"ATMOSPHERE","pdim txt txtend")gW[#gW+1]=c8(j8,j4,e("%.2f",ar),"pdim txt txtend","")end;gW[#gW+1]=c8(j2,j3,"GRAVITY","pdim txt txtend")gW[#gW+1]=c8(j2,j4,e("%.2f",j5/9.80665),"pdim txt txtend")gW[#gW+1]=c8(j2,j3+20,"ACCEL","pdim txt txtend")gW[#gW+1]=c8(j2,j4+20,e("%.2f",j7),"pdim txt txtend")gW[#gW+1]=c8(gi(960),gj(180),gm,"txtbig txtmid")end;function iU.DrawOdometer(gW,ad,TotalDistanceTravelled,ae)local j5;local j9=0;local ja=0;local j6=0;local jb=av>1000000 and z(av/1000000,2).." kTons"or z(av/1000,2).." Tons"if aq then j6=LastMaxBrakeInAtmo else j6=LastMaxBrake end;local jc,jd=aT.computeDistanceAndTime(bt,0,av,0,0,j6)j6=z(j6/(av*g9),2).." g"local je=a:maxForceForward()j5=core.g()if j5>0.1 then ja=av*j5;ja=z(ja/(av*g9),2).." g"j9=0.5*je/j5;j9=j9>1000000 and z(j9/1000000,2).." kTons"or z(j9/1000,2).." Tons"end;je=z(je/(av*g9),2).." g"gW[#gW+1]=e([[
                        <g class="pbright txt">
                        <path class="linethick" d="M %d 0 L %d %d Q %d %d %d %d L %d 0"/>]],gi(660),gi(700),gj(35),gi(960),gj(55),gi(1240),gj(35),gi(1280))if l()==0 or RemoteHud then gW[#gW+1]=c8(gi(700),gj(10),e("BrkTime: %s",cw(jd)),"txtstart")gW[#gW+1]=c8(gi(700),gj(20),e("Trip: %.2f km",ad),"txtstart")gW[#gW+1]=c8(gi(700),gj(30),e("Lifetime: %.2f kSU",TotalDistanceTravelled/200000),"txtstart")gW[#gW+1]=c8(gi(830),gj(10),e("BrkDist: %s",cl(jc)),"txtstart")gW[#gW+1]=c8(gi(830),gj(20),"Trip Time: "..cw(ae),"txtstart")gW[#gW+1]=c8(gi(830),gj(30),"Total Time: "..cw(TotalFlightTime),"txtstart")gW[#gW+1]=c8(gi(970),gj(20),e("Mass: %s",jb),"txtstart")gW[#gW+1]=c8(gi(1240),gj(10),e("Max Brake: %s",j6),"txtend")gW[#gW+1]=c8(gi(1240),gj(30),e("Max Thrust: %s",je),"txtend")if j5>0.1 then gW[#gW+1]=c8(gi(970),gj(30),e("Max Thrust Mass: %s",j9),"txtstart")gW[#gW+1]=c8(gi(1240),gj(20),e("Req Thrust: %s",ja),"txtend")else gW[#gW+1]=c8(gi(970),gj(30),"Max Mass: n/a","txtstart")gW[#gW+1]=c8(gi(1240),gj(20),"Req Thrust: n/a","txtend")end end;gW[#gW+1]="</g>"return gW end;function iU.DrawWarnings(gW)return ia(gW)end;function iU.DisplayOrbitScreen(gW)return io(gW)end;function iU.DisplayMessage(gW,ik)if ik~="empty"then local ca=310;for jf in string.gmatch(ik,"([^\n]+)")do ca=ca+35;gW[#gW+1]=c8("50%",ca,jf,"msg")end end;if ai~=0 then unit.setTimer("msgTick",ai)ai=0 end end;function iU.DrawDeadZone(gW)gW[#gW+1]=e([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function iU.UpdatePipe()if aq then bJ=""return end;iL()end;function iU.DrawSettings(gW)if#bF>0 then local c9=gi(640)local ca=gj(200)gW[#gW+1]=[[<g class="pbright txtvspd txtstart">]]for cF,cG in pairs(bF)do gW[#gW+1]=c8(c9,ca,cG..": ".._G[cG])ca=ca+20;if cF%12==0 then c9=c9+gi(350)ca=gj(200)end end;gW[#gW+1]=c8(gi(640),gj(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")gW[#gW+1]="</g>"end;return gW end;local jg;local jh=gi(1770)local ji=gj(350)local jj=gj(15)local jk=gi(1370)local jl,jm;local jn=0;function iU.DrawRadarInfo()local function jo()if radarPanelID~=nil and jn==0 then s(radarPanelID)radarPanelID=nil;if jg~=nil then s(jg)jg=nil end else if jn==1 then s(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_periscope", "Periscope"),"periscope")jg=_autoconf.panels[_autoconf.panels_size]end;placeRadar=true;if radarPanelID==nil and placeRadar then _autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_radar", "Radar"),"radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]placeRadar=false end;jn=0 end end;local f1,f2,f0,f3,f4,eY=aZ.GetRadarHud()local A=f3 or 0;if f0>0 then if CollisionSystem then jl=A.."/"..f4 .." Plotted : "..f0-f4 .." Ignored"else jl="Radar Contacts: "..f0 end;gn=c8(jh,ji,jl,"pbright txtbig txtmid")if#eY>0 then gn=gn..c8(jk,jj,"Friendlies In Range","pbright txtbig txtmid")for cF,cG in pairs(eY)do jj=jj+20;gn=gn..c8(jk,jj,radar_1.getConstructName(cG),"pdim txtmid")end end;if f1==nil and jg==nil then jn=1;jo()end;if f1~=nil and jg~=nil then jo()end;if radarPanelID==nil then jo()end else if f2 then gn=c8(jh,ji,"Radar: Jammed","pbright txtbig txtmid")else gn=c8(jh,ji,"Radar: No Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then jn=0;jo()end end end;function iU.DrawTanks()if fuelX~=0 and fuelY~=0 then go=c8(fuelX,fuelY,"","txtstart pdim txtfuel")gF(fuelX,"Atmospheric ","ATMO",aI,gD,gE)gF(fuelX+120,"Space fuel t","SPACE",aJ,gB,gC)gF(fuelX+240,"Rocket fuel ","ROCKET",aK,gz,gA)end end;function iU.DrawShield()local jp=shield_1.getState()==1 and"Shield Active"or"Shield Disabled"local jq=core.getPvPTimer()local jr=shield_1.getResistances()local js="A: "..10+jr[1]*100 .."% / E: "..10+jr[2]*100 .."% / K:"..10+jr[3]*100 .."% / T: "..10+jr[4]*100 .."%"local c9,ca=shieldX-60,shieldY+30;local jt=d(0.5+shield_1.getShieldHitpoints()*100/shield_1.getMaxShieldHitpoints())local gT=d(jt*2.55)local gU=e("rgb(%d,%d,%d)",255-gT,gT,0)local cc=""gp=c8(c9,ca,"","txtmid pdim txtfuel")if jt<10 and jp~="Shield Disabled"then cc="red "end;jq=jq>0 and"   PvPTime: "..cw(jq)or""gp=gp..e([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],c9,ca,gU,jt*2,c9,ca,c9+2,ca+10,jt,jq)gp=gp..c8(c9,ca-5,jp,cc.."txtstart pbright txtbig")gp=gp..c8(c9,ca+30,js,cc.."txtstart pbright txtsmall")end;return iU end;local function ju()local function jv(position)local p=sys:closestBody(position)if(position-p.center):len()>p.radius+p.noAtmosphericDensityAltitude then p=aN[0][0]end;return p end;local function jw()local function jx(jy,jz)return jy.name<jz.name end;bH={}for cF,cG in pairs(aN[0])do bH[#bH+1]={name=cG.name,index=cF}end;table.sort(bH,jx)end;local function jA(jB)for cF,cG in pairs(jB)do if cG.name and cG.name==CustomTarget.name then return cF end end;return-1 end;local function jC()if AutopilotTargetIndex==0 then AutopilotTargetName="None"ac=nil;CustomTarget=nil;return true end;local jD=bH[AutopilotTargetIndex].index;local jE=aN[0][jD]if jE.center then AutopilotTargetName=jE.name;ac=aS[0][jD]if CustomTarget~=nil then if ar==0 then if t(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if t(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if t(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then u(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if t(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if t(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if t(widgetMaxMassText,widgetMaxMass)~=1 then u(widgetMaxMassText,widgetMaxMass)end;if t(widgetTravelTimeText,widgetTravelTime)~=1 then u(widgetTravelTimeText,widgetTravelTime)end;if t(widgetTargetOrbitText,widgetTargetOrbit)~=1 then u(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=jE;for _,cG in pairs(aS[0])do if cG.name==CustomTarget.planetname then ac=cG;AutopilotTargetName=CustomTarget.name;break end end;if t(widgetMaxMassText,widgetMaxMass)~=1 then u(widgetMaxMassText,widgetMaxMass)end;if t(widgetTravelTimeText,widgetTravelTime)~=1 then u(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(ac.center)else AutopilotTargetCoords=CustomTarget.position end;if ac.planetname~="Space"then if ac.hasAtmosphere then AutopilotTargetOrbit=d(ac.radius*(TargetOrbitRadius-1)+ac.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=d(ac.radius*(TargetOrbitRadius-1)+ac.surfaceMaxAltitude)end else AutopilotTargetOrbit=AutopilotSpaceDistance end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=aV(ac):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;local function jF(g_)if not Autopilot and not VectorToTarget and not am and not IntoOrbit then if g_==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#bH then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#bH end end;if AutopilotTargetIndex==0 then jC()else local jD=bH[AutopilotTargetIndex].index;local jE=aN[0][jD]if jE~=nil and jE.name=="Space"or iphCondition=="Custom Only"and jE.center or iphCondition=="No Moons"and string.find(jE.name,"Moon")~=nil then if g_==nil then jF()else jF(1)end else jC()end end else a2="Disengage autopilot before changing Interplanetary Helper"bW("iph","AP")end end;local function jG()local fJ=-1;fJ=jA(aN[0])if fJ>-1 then table.remove(aN[0],fJ)end;fJ=-1;fJ=jA(SavedLocations)if fJ~=-1 then a2=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,fJ)end;jF()jw()end;local function jH(fY,position,hH,jI)if dbHud_1 or hH then local p=jv(position)local j5=p.gravity;local jJ=p.atmosphericDensityAboveSurface;if jI then jJ=ar;j5=unit.getClosestPlanetInfluence()end;local jK={position=position,name=fY,atmosphere=jJ,planetname=p.name,gravity=j5,safe=jI}if not hH then SavedLocations[#SavedLocations+1]=jK else for cF,cG in pairs(aN[0])do if cG.name and fY==cG.name then table.remove(aN[0],cF)end end end;table.insert(aN[0],jK)jw()jC()a2="Location saved as "..fY.."("..p.name..")"else a2="Databank must be installed to save permanent locations"end end;local cH={}function cH.UpdateAtlasLocationsList()jw()end;function cH.UpdateAutopilotTarget()jC()end;function cH.adjustAutopilotTargetIndex(g_)jF(g_)end;function cH.findAtlasIndex(jB)jA(jB)end;function cH.UpdatePosition(jL)local fJ=jA(SavedLocations)if fJ~=-1 then if jL~=nil then SavedLocations[fJ].name=jL;AutopilotTargetIndex=AutopilotTargetIndex-1;jF()else local jM=SavedLocations[fJ]jM.atmosphere=ar;jM.gravity=unit.getClosestPlanetInfluence()jM.position=bw;jM.safe=true end;a2=SavedLocations[fJ].name.." position updated ("..SavedLocations[fJ].planetname..")"else a2="Name Not Found"end end;function cH.AddNewLocation(fY,position,hH,jI)jH(fY,position,hH,jI)end;function cH.ClearCurrentPosition()jG()end;for cF,cG in pairs(SavedLocations)do table.insert(aN[0],cG)end;jw()cH.UpdateAutopilotTarget()return cH end;local function jN()local jO={}local function jP(ew)local jQ=AutopilotEndSpeed;if not Autopilot then jQ=0 end;if not aq then return aT.computeDistanceAndTime(ew,jQ,av,0,0,LastMaxBrake-AutopilotPlanetGravity*av)else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return aT.computeDistanceAndTime(ew,jQ,av,0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*av)else return 0,0 end end end;local function jR(ew)local jQ=AutopilotEndSpeed;if not Autopilot then jQ=0 end;return aT.computeDistanceAndTime(ew,jQ,av,a:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*av)end;local jS=false;function jO.GetAutopilotBrakeDistanceAndTime(ew)return jP(ew)end;function jO.GetAutopilotTBBrakeDistanceAndTime(ew)return jR(ew)end;local function jT(jU,jV,jW)jV=jV:project_on_plane(jU)jW=jW:project_on_plane(jU)return m(jV:cross(jW):dot(jU),jV:dot(jW))end;local function jX()local function jY()local jZ=-1;local j_=-1;if vBooster then jZ=vBooster.distance()end;if hover then j_=hover.distance()end;if jZ~=-1 and j_~=-1 then if jZ<j_ then return jZ else return j_ end elseif jZ~=-1 then return jZ elseif j_~=-1 then return j_ else return-1 end end;local k0=jY()local k1=-1;if telemeter_1 then k1=telemeter_1.getDistance()end;if k0~=-1 and k1~=-1 then if k0<k1 then return k0 else return k1 end elseif k0~=-1 then return k0 else return k1 end end;local function k2(planet,dT,k3)local function k4(k5,da)local dZ=vec3(da)if k5.bodyId==0 then return setmetatable({latitude=dZ.x,longitude=dZ.y,altitude=dZ.z,bodyId=0,systemId=k5.planetarySystemId},MapPosition)end;local d_=dZ-k5.center;local aj=d_:len()local dg=aj-k5.radius;local de=0;local df=0;if not ci(aj,0)then local e0=m(d_.y,d_.x)df=e0>=0 and e0 or 2*math.pi+e0;de=math.pi/2-math.acos(d_.z/aj)end;return setmetatable({latitude=math.deg(de),longitude=math.deg(df),altitude=dg,bodyId=k5.bodyId,systemId=k5.planetarySystemId},MapPosition)end;local k6=k4(planet,dT)k6="::pos{"..k6.systemId..","..k6.bodyId..","..k6.latitude..","..k6.longitude..","..k6.altitude.."}"if k3 then return k6 else system.setWaypoint(k6)return true end end;local k7=false;function jO.showWayPoint(planet,dT,k3)return k2(planet,dT,k3)end;function jO.APTick()local function k8()if bO and not BrakeLanding then local bU=bO[1]local fZ,f_=bO[2],bO[3]local k9=math.min(fZ,f_ or fZ)local ka=k9/bt;local kb=AutoTakeoff and(bt<42 or ao~=-1)local kc=AltitudeHold or VectorToTarget or LockPitch or Autopilot;if kc and not kb and(a8*1.5>k9 or ka<1)then BrakeIsOn=true;ce(0)if AltitudeHold then cq()end;if LockPitch then ToggleLockPitch()end;a2="Autopilot Cancelled due to possible collision"if VectorToTarget or Autopilot then cr()end;StrongBrakes=true;BrakeLanding=true;b1=true end;if ka<11 then bN=bU.name.." COLLISION "..cw(ka).." / "..cl(k9,2)else bN=bU.name.." collision "..cw(ka)end;if ka<6 then bW("alarm","AL",2)end else bN=false end end;local function kd(bQ,ke,kf)local function kg(bQ,dF)bQ=vec3(bQ)dF=vec3(dF):normalize()local cX=bQ*dF;return cX.x+cX.y+cX.z end;local kh=0.001;local ki=1;if not aq or not b3 or ao~=-1 or bt<Q then if kf==nil then kf=DampingMultiplier end;if ke==nil then ke=kh end;bQ=vec3(bQ):normalize()local kj=vec3()-bQ;local kk=-kg(kj,core.getConstructWorldOrientationRight())*ki;local kl=-kg(kj,core.getConstructWorldOrientationUp())*ki;if aB==0 then aB=kk/2 end;if aC==0 then aC=kl/2 end;if c(kk)<0.1 then V=V-kk*2 else V=V-(kk+(kk-aB)*kf)end;if c(kl)<0.1 then U=U+kl*2 else U=U+kl+(kl-aC)*kf end;aB=kk;aC=kl;if c(kk)<ke and c(kl)<ke then return true end;return false elseif b3 and ao==-1 then bQ=bs;if kf==nil then kf=DampingMultiplier end;if ke==nil then ke=kh end;bQ=vec3(bQ):normalize()local kj=bp-bQ;local kk=-kg(kj,core.getConstructWorldOrientationRight())*ki;local kl=-kg(kj,core.getConstructWorldOrientationUp())*ki;if aB==0 then aB=kk/2 end;if aC==0 then aC=kl/2 end;if c(kk)<0.1 then V=V-kk*5 else V=V-(kk+(kk-aB)*kf)end;if c(kl)<0.1 then U=U+kl*5 else U=U+kl+(kl-aC)*kf end;aB=kk;aC=kl;if c(kk)<ke and c(kl)<ke then return true end;return false end end;aq=j()>0;ar=j()as=core.getAltitude()ao=jX()D=o()b4=D;if CollisionSystem then k8()end;if antigrav then bz=antigrav.getState()==1 end;local km=1;local kn=1;local ko=D-b4;local kp=-math.deg(jT(bo,bs,bp))local kq=math.deg(jT(bq,bs,bp))local g_=bu*-1;b3=aq and kp<-YawStallAngle or kp>YawStallAngle or kq<-PitchStallAngle or kq>PitchStallAngle;local kr=system.getMouseDeltaX()local ks=system.getMouseDeltaY()if InvertMouse and not a1 then ks=-ks end;V=0;Z=0;U=0;sys=aS[0]planet=sys:closestBody(core.getConstructWorldPos())kepPlanet=aV(planet)orbit=kepPlanet:orbitalParameters(core.getConstructWorldPos(),bs)if as==0 then as=(bw-planet.center):len()-planet.radius end;bM=unit.getClosestPlanetInfluence()>0 or as>0 and as<200000;local j5=planet:getGravity(core.getConstructWorldPos()):len()*av;b5=0;aU=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]if w()==0 then if l()==1 and a1 then if not a_ then ag=ag+kr;ah=ah+ks end else ag=0;ah=0 end else ag=ag+kr;ah=ah+ks;aj=x(ag*ag+ah*ah)if not a1 and l()==0 then if userControlScheme=="virtual joystick"then if ag>0 and ag>DeadZone then V=V-(ag-DeadZone)*MouseXSensitivity elseif ag<0 and ag<DeadZone*-1 then V=V-(ag+DeadZone)*MouseXSensitivity else V=0 end;if ah>0 and ah>DeadZone then U=U-(ah-DeadZone)*MouseYSensitivity elseif ah<0 and ah<DeadZone*-1 then U=U-(ah+DeadZone)*MouseYSensitivity else U=0 end else ag=0;ah=0;if userControlScheme=="mouse"then U=(-utils.smoothstep(ks,-100,100)+0.5)*2*km;V=(-utils.smoothstep(kr,-100,100)+0.5)*2*kn end end end end;local kt=bt>8334;if bt>SpaceSpeedLimit/3.6 and not aq and not Autopilot and not kt then a2="Space Speed Engine Shutoff reached"ce(0)end;if not kt and LastIsWarping then if not BrakeIsOn then ct()end;if Autopilot then cr()end end;LastIsWarping=kt;if aq and ar>0.09 then if bt>b8/3.6 and not AtmoSpeedAssist and not jS then BrakeIsOn=true;jS=true elseif not AtmoSpeedAssist and jS then if bt<b8/3.6 then BrakeIsOn=false;jS=false end end end;if BrakeIsOn then Y=1 else Y=0 end;if ProgradeIsOn then if al then BrakeIsOn=false;local ku=false;if CustomTarget~=nil and al~=1 then ku=kd(CustomTarget.position-bw,0.1)else ku=kd(vec3(bs),0.01)end;b1=true;if ku then ch(d(b8))if(c(bD)<2 or c(bC)>85)and bt>=b8/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;R=true;if al~=1 then an=true end;al=false;Autopilot=false;cu()end elseif aq and AtmoSpeedAssist then ce(1)end elseif bt>Q then kd(vec3(bs),0.01)end end;if RetrogradeIsOn then if aq then RetrogradeIsOn=false elseif bt>Q then kd(-vec3(bs))end end;if not ProgradeIsOn and al and not IntoOrbit then if ar==0 then R=true;cu()al=false;an=true else al=false;cr()end end;if an and CustomTarget~=nil and(as<HoldAltitude+250 and as>HoldAltitude-250)and bt*3.6>b8-250 and c(bv)<25 and ar>=0.1 and(CustomTarget.position-bw):len()>2000+as then cr()an=false end;if VertTakeOff then b1=true;local kv=HoldAltitude;if bv<-30 then a2="Unable to achieve lift. Safety Landing."af=0;b1=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and bz or HoldAltitude<planet.spaceEngineMinAltitude then if bz then kv=antigrav.getBaseAltitude()end;if as<kv-100 then b9=0;af=15;BrakeIsOn=false elseif bv>0 then BrakeIsOn=true;af=0 elseif bv<-30 then BrakeIsOn=true;af=15 elseif as>=kv then if bz then if Autopilot or VectorToTarget then co()else BrakeIsOn=true;VertTakeOff=false end;a2="Takeoff complete. Singularity engaged"bW("aggLk","AG")else BrakeIsOn=false;a2="VTO complete. Engaging Horizontal Flight"bW("vtoc","VT")co()end;af=0 end else if ar>0.08 then b9=0;BrakeIsOn=false;af=20 elseif ar<0.08 and ar>0 then BrakeIsOn=false;if bl then b9=0;af=20 else af=0;b9=36;ch(3500)end else b1=autoRollPreference;IntoOrbit=true;bj=false;CancelIntoOrbit=false;bd=false;bb=nil;bc=nil;if bi==nil then bi=planet end;bh=kv;bg=true;VertTakeOff=false end end;if b9~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local kw=q(b9-bC,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(kw)local kx=q(vTpitchPID:get(),-1,1)U=kx end end;if IntoOrbit then local kj;local ky=false;local kz=cl(bh)if bi==nil then bi=planet;if VectorToTarget then bi=ac end end;if not bg then bh=d(bi.radius+bi.surfaceMaxAltitude+LowOrbitHeight)if bi.hasAtmosphere then bh=d(bi.radius+bi.noAtmosphericDensityAltitude+LowOrbitHeight)end;bg=true end;if bf.VectorToTarget then kj=CustomTarget.position-bw end;local kA,kB=aV(bi):escapeAndOrbitalSpeed((bw-bi.center):len()-bi.radius)local kC=bD;if not bd then local kD=false;local kE=false;ce(0)bc=0;ba="Aligning to orbital path - OrbitHeight: "..kz;if bf.VectorToTarget then kd(kj:normalize():project_on_plane(bu))ky=bp:dot(kj:project_on_plane(bo):normalize())>0.95 else kd(bs)ky=kp<0.5;if bt<150 then ky=true end end;U=0;bb=0;if bC<=bb+1 and bC>=bb-1 then kD=true else kD=false end;if kC<=bc+1 and kC>=bc-1 then kE=true else kE=false end;if kD and kE and ky then bb=nil;bc=nil;bd=true end else if bf.VectorToTarget then kd(kj:normalize():project_on_plane(bu))elseif bt>150 then kd(bs)end;U=0;if bf.VectorToTarget then local a8,_=aT.computeDistanceAndTime(bt,b8/3.6,av,0,0,LastMaxBrake)if bj and kj:len()>15000+a8+as then ba="Orbiting to Target"if as-100<=bi.noAtmosphericDensityAltitude or travelTime>orbit.timeToPeriapsis and orbit.periapsis.altitude<bi.noAtmosphericDensityAltitude then bj=false end elseif bj or kj:len()<15000+a8+as then a2="Orbit complete, proceeding with reentry"bW("orCom","OB")AutopilotTargetCoords=CustomTarget.position;R=true;an=true;bf.VectorToTarget,bf.AutopilotAlign=false,false;cp()cu()end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and as>bh*0.9 and as<bh*1.4 then if orbit.apoapsis~=nil then if orbit.periapsis.altitude>=bh*0.99 and orbit.apoapsis.altitude>=bh*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or bj then if bj then BrakeIsOn=false;ce(0)bb=0;if not bf.VectorToTarget then a2="Orbit complete"bW("orCom","OB")cp()end else bn=bn+1;if bn>=2 then bj=true end end else ba="Adjusting Orbit - OrbitHeight: "..kz;be=true;ch(kB*3.6+1)if VSpdPID==nil then VSpdPID=pid.new(0.5,0,10*0.1)end;local kF=bv;local kG=as-bh;local kH=c(kG)if bv<10 and c(bC)<10 and kH<100 then kF=bv*2 end;if kF<10 and c(bC)<10 and kH<100 then kF=kF*2 end;if kF<5 and c(bC)<5 and kH<100 then kF=kF*4 end;VSpdPID:inject(kF)bb=q(-VSpdPID:get(),-90,90)if OrbitAltPID==nil then OrbitAltPID=pid.new(0.15,0,5*0.1)end;OrbitAltPID:inject(kG)bb=q(bb-q(OrbitAltPID:get(),-15,15),-90,90)end end else local kI=2.75;local kJ=c(z(kA*kI))local kK=kJ%50;if kK>0 then kJ=kJ-kK+50 end;BrakeIsOn=false;if as<bh*0.8 then ba="Escaping planet gravity - OrbitHeight: "..kz;bb=utils.map(bv,200,0,-15,80)elseif as>=bh*0.8 and as<bh*1.15 then ba="Approaching orbital corridor - OrbitHeight: "..kz;kJ=kJ*0.75;bb=utils.map(bv,100,-100,-15,65)elseif as>=bh*1.15 and as<bh*1.5 then ba="Approaching orbital corridor - OrbitHeight: "..kz;kJ=kJ*0.75;if bv<0 or be then bb=utils.map(as,bh*1.5,bh*1.01,-30,0)else bb=utils.map(as,bh*0.99,bh*1.5,0,30)end elseif as>bh*1.5 then ba="Reentering orbital corridor - OrbitHeight: "..kz;bb=-65;local kL=utils.map(bv,-150,-400,1,0.55)kJ=kJ*kL end;ch(d(kJ))end end;if bb~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local kM=bb-bC;OrbitPitchPID:inject(kM)local kN=q(OrbitPitchPID:get(),-0.5,0.5)U=kN end end;if Autopilot and ar==0 and not al then local function kO(jl,orbit)system.print(jl)BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"ce(0)P=false;a2=jl;bW("apCom","AP")if orbit or al then if orbit and AutopilotTargetOrbit~=nil and not al then if not as or as==0 then return end;bh=as;bg=true end;cp()end end;local kP,kQ=AutopilotTargetCoords,false;if CustomTarget~=nil and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local kR=(CustomTarget.position-ac.center):normalize()local kS=kR:project_on_plane((ac.center-bw):normalize()):normalize()local kT=ac.center+kS*(ac.radius+AutopilotTargetOrbit)local kU=CustomTarget.position+(CustomTarget.position-ac.center):normalize()*(AutopilotTargetOrbit-ac:getAltitude(CustomTarget.position))if(bw-kT):len()<(bw-kU):len()then kP=kT else kP=kU;AutopilotEndSpeed=0 end;AutopilotTargetCoords=kP;aY.showWayPoint(ac,AutopilotTargetCoords)kQ=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotPlanetGravity=0;kQ=true;TargetSet=true;AutopilotRealigned=true;kP=CustomTarget.position+(bw-CustomTarget.position)*AutopilotTargetOrbit elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local kR=(bw+bs*100000-ac.center):normalize()local kS=kR:project_on_plane((ac.center-bw):normalize()):normalize()if kS:len()<1 then kR=(bw+bp*100000-ac.center):normalize()kS=kR:project_on_plane((ac.center-bw):normalize()):normalize()end;kP=ac.center+kS*(ac.radius+AutopilotTargetOrbit)AutopilotTargetCoords=kP;TargetSet=true;kQ=true;AutopilotRealigned=true;aY.showWayPoint(ac,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(kP)-bw):len()local bR,bS,bT=aS:getPlanetarySystem(0):castIntersections(bw,bs:normalize(),function(bU)if bU.noAtmosphericDensityAltitude>0 then return bU.radius+bU.noAtmosphericDensityAltitude else return bU.radius+bU.surfaceMaxAltitude*1.5 end end)local bV=bS;if bT~=nil and bS~=nil then bV=math.min(bT,bS)end;if bV~=nil and bV<AutopilotDistance and bR.name==ac.name then AutopilotDistance=bV end;local ku=true;local kV=(ac.center-(bw+vec3(bs):normalize()*AutopilotDistance)):len()-ac.radius;local ik=cl(kV)t(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..ik..'"}')local a8,a9;if not TurnBurn then a8,a9=jP(bt)else a8,a9=jR(bt)end;if bt>300 and AutopilotAccelerating then local kj=vec3(kP)-bw;local kW=q(math.deg(jT(bo,bs:normalize(),kj:normalize()))*bt/500,-90,90)local kX=q(math.deg(jT(bq,bs:normalize(),kj:normalize()))*bt/500,-90,90)if c(kW)<20 and c(kX)<20 then kW=kW*2;kX=kX*2 end;if c(kW)<2 and c(kX)<2 then kW=kW*2;kX=kX*2 end;local kp=-math.deg(jT(bo,bp,bs:normalize()))local kq=-math.deg(jT(bq,bp,bs:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(kX-kq)local kY=q(apPitchPID:get(),-1,1)U=U+kY;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(kW-kp)local kZ=q(apYawPID:get(),-1,1)V=V+kZ;kQ=true;if c(kW)>2 or c(kX)>2 then if AutopilotStatus~="Adjusting Trajectory"then AutopilotStatus="Adjusting Trajectory"bW("apAdj","AP")end else if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bW("apAcc","AP")end end end;if kV<AutopilotTargetOrbit*1.5 then if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=aV(ac):escapeAndOrbitalSpeed(kV)end end;if Autopilot and not AutopilotAccelerating and not AutopilotCruising and not AutopilotBraking then local bR,bV=bP((AutopilotTargetCoords-bw):normalize())if ac.name~=planet.name then if bR~=nil and ac.name~=bR.name then a2="Collision with "..bR.name.." in "..cl(bV).."\nClear LOS to continue."ai=5;k7=true else k7=false;a2=""end end end;if not k7 then if not AutopilotCruising and not AutopilotBraking and not kQ then ku=kd((kP-bw):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then ku=kd(-vec3(bs):normalize())end end;if AutopilotAccelerating then if not P then BrakeIsOn=false;ce(AutopilotInterplanetaryThrottle)K=z(AutopilotInterplanetaryThrottle,2)P=true end;local k_=unit.getThrottle()if AtmoSpeedAssist then k_=K end;if br:len()>=MaxGameVelocity or k_==0 and P then AutopilotAccelerating=false;if AutopilotStatus~="Cruising"then bW("apCru","AP")AutopilotStatus="Cruising"end;AutopilotCruising=true;ce(0)end;local l0=AutopilotDistance;if ac.name=="Space"then l0=l0-AutopilotSpaceDistance end;if l0<=a8 then AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bW("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true;ce(0)P=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;Y=1 end;if TurnBurn then ce(1,true)end;local _,kB=aV(ac):escapeAndOrbitalSpeed((bw-planet.center):len()-planet.radius)local kj;if CustomTarget~=nil then kj=CustomTarget.position-bw end;if CustomTarget~=nil and CustomTarget.planetname=="Space"and bt<50 then kO("Autopilot complete, arrived at space location")BrakeIsOn=true;Y=1 elseif CustomTarget~=nil and CustomTarget.planetname~="Space"and bt<=kB and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then kO("Autopilot complete, commencing reentry")AutopilotTargetCoords=CustomTarget.position;al=true;aY.showWayPoint(ac,AutopilotTargetCoords)elseif orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 or AutopilotStatus=="Circularizing"then if AutopilotStatus~="Circularizing"then bW("apCir","AP")AutopilotStatus="Circularizing"end;if bt<=kB then if CustomTarget~=nil then if bs:normalize():dot(kj:normalize())>0.4 then if AutopilotStatus~="Orbiting to Target"then bW("apOrb","OB")AutopilotStatus="Orbiting to Target"end;if not WaypointSet then BrakeIsOn=false;aY.showWayPoint(ac,CustomTarget.position)WaypointSet=true end else kO("Autopilot complete, proceeding with reentry")AutopilotTargetCoords=CustomTarget.position;al=true;aY.showWayPoint(ac,CustomTarget.position)WaypointSet=false end else kO("Autopilot completed, setting orbit",true)Y=0 end end elseif AutopilotStatus=="Circularizing"then kO("Autopilot complete, fixing Orbit",true)end elseif AutopilotCruising then local l0=AutopilotDistance;if ac.name=="Space"then l0=l0-AutopilotSpaceDistance end;if l0<=a8 then AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bW("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true end;local k_=unit.getThrottle()if AtmoSpeedAssist then k_=K end;if k_>0 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bW("apAcc","AP")end;AutopilotCruising=false end else if ku then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget~=nil and CustomTarget.planetname~="Space"then if not al then AutopilotTargetCoords=vec3(ac.center)+(AutopilotTargetOrbit+ac.radius)*bq;AutopilotShipUp=bo;AutopilotShipRight=bq end;AutopilotRealigned=true elseif ku and not k7 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bW("apAcc","AP")end;if not P then ce(AutopilotInterplanetaryThrottle,true)K=z(AutopilotInterplanetaryThrottle,2)P=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and ar>0)then a2="Autopilot complete, starting reentry"bW("apCom","AP")AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"Y=0;ce(0)P=false;ProgradeIsOn=true;al=true;aY.showWayPoint(ac,CustomTarget.position)p('NEXT TARGET ATMO')MPRN_NextTarget()end;if a0 then b1=true;local kX=0;local eA=bw+vec3(unit.getMasterPlayerRelativePosition())local l1=eA-bw;local l2=vec3(l1):project_on(bp):len()local l3=vec3(l1):project_on(bq):len()local aj=x(l2*l2+l3*l3)kd(l1:normalize())local l4=40;local l5=aj<l4;local l6=100;local l7=q((aj-l4)/2,10,l6)U=0;local ku=c(V)<0.1;if ku and bt<l7 and not l5 then BrakeIsOn=false;kX=-20 else BrakeIsOn=true;kX=0 end;local l8=0;if c(kX-bC)>l8 then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(kX-bC)local kY=pitchPID:get()U=kY end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local l9=LastMaxBrakeInAtmo;if l9 then l9=l9*q(bt/100,0.1,1)*ar else l9=LastMaxBrake end;if ar<0.01 then l9=LastMaxBrake end;local la=vec3(core.getWorldAirFrictionAcceleration())local lb=x(la:len()-la:project_on(g_):len())*av;if bt>100 then a8,a9=aT.computeDistanceAndTime(bt,100,av,0,0,l9+lb)local lc,ld=aT.computeDistanceAndTime(100,0,av,0,0,l9/2)a8=a8+lc else a8,a9=aT.computeDistanceAndTime(bt,0,av,0,0,l9/2)end;local le=HoldAltitude-as;local lf=500+bt;local lg=1;if AutoTakeoff then lg=q(bt/100,0.1,1)end;local kX=(utils.smoothstep(le,-lf,lf)-0.5)*2*MaxPitch*lg;if not Reentry and not al and not VectorToTarget and bp:dot(bs:normalize())<0.99 then kX=(utils.smoothstep(le,-lf*q(20-19*ar*10,1,20),lf*q(20-19*ar*10,1,20))-0.5)*2*MaxPitch*q(2-ar*10,1,2)*lg end;if not AltitudeHold then kX=0 end;if LockPitch~=nil then if bM and not IntoOrbit then kX=LockPitch else LockPitch=nil end end;b1=true;local lh=U;if Reentry then local li=d(b8)local lj,lk=aT.computeDistanceAndTime(bt,li/3.6,av,0,0,LastMaxBrake-planet.gravity*9.8*av)lj=lj==-1 and 5000 or lj;local ll=as-(planet.noAtmosphericDensityAltitude+lj)local lm=as>planet.noAtmosphericDensityAltitude+lj*1.35;if lm then kX=ReEntryPitch;if bt<=li/3.6 and bt>li/3.6-10 and c(bs:normalize():dot(bp))>0.9 and not bB then O=false;ce(1)end elseif bB and not lm and not aq then ch(li,true)end;if bB then if bt>li/3.6 and not lm then BrakeIsOn=true else BrakeIsOn=false end else BrakeIsOn=false end;if bv>0 then BrakeIsOn=true end;if not R then kX=-80;if ar>0.02 then a2="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;kX=0;b1=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and lm then b1=true elseif not lm then if not aq and(bB or r:getTargetSpeed(axisCommandId.longitudinal)~=li)then ch(li)end;if bt<li/3.6+1 then BrakeIsOn=false;R=false;Reentry=false;b1=true end end end;if bt>Q and not am and not VectorToTarget and not BrakeLanding and ForceAlignment then kd(vec3(bs))end;if bK or(VectorToTarget or am)and AutopilotTargetIndex>0 and ar>0.01 then local kj;if bK then if type(bK)=="table"then kj=bK elseif bK<3 and bK>0 then kj=-bu:cross(bs)*5000 elseif bK>=3 then kj=bu:cross(bs)*5000 elseif bK<0 then kj=bs*25000 end elseif CustomTarget~=nil then kj=CustomTarget.position-bw else kj=ac.center-bw end;local kW=math.deg(jT(bu:normalize(),bs,kj))*2;local ln=math.rad(c(bD))if bt>minRollVelocity and ar>0.01 then local lo=q(90-kX*2,-90,90)b5=q(kW*2,-lo,lo)local lp=kW;kW=q(q(kW,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(ln)+4*(bC-kX)*math.sin(math.rad(bD)),-YawStallAngle*0.80,YawStallAngle*0.80)kX=q(q(kX*math.cos(ln),-PitchStallAngle*0.80,PitchStallAngle*0.80)+c(q(c(lp)*math.sin(ln),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else b5=0;kW=q(kW,-YawStallAngle*0.80,YawStallAngle*0.80)end;local lq=kp-kW;if bK and c(lq)<=0.0001 and(type(bK)=="table"or type(bK)~="table"and bK<0 and c(bD)<1)then if bK==-2 then cq()end;bK=nil;bW("180Off","BR")return end;if not b3 and bt>minRollVelocity and ar>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(lq)local kZ=q(yawPID:get(),-1,1)V=V+kZ elseif aq and ao>-1 or bt<minRollVelocity then kd(kj)elseif b3 and ar>0.01 then if(kp<-YawStallAngle or kp>YawStallAngle)and ar>0.01 then kd(bs)end;if(kq<-PitchStallAngle or kq>PitchStallAngle)and ar>0.01 then kX=q(bC-kq,bC-PitchStallAngle*0.80,bC+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not am then local kv=planet:getAltitude(CustomTarget.position)local ll=x(kj:len()^2-(as-kv)^2)local lr=bs:len()-c(bv)StrongBrakes=true;if not am and not Reentry and ll<=a8+bt*ko/2 and(bs:project_on_plane(bu):normalize():dot(kj:project_on_plane(bu):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"ce(0)if AltitudeHold then cq()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(lr<0.1 or ll<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<ll)then if not bz then bW("bklOn","BL")BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"bN=false end;LastDistanceToTarget=ll end elseif VectorToTarget and ar==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(am or Reentry)then if CustomTarget~=nil and ac.name==planet.name then local kj=CustomTarget.position-bw;local kv=planet:getAltitude(CustomTarget.position)local ll=x(kj:len()^2-(as-kv)^2)local l9=LastMaxBrakeInAtmo;if l9 then a8,a9=aT.computeDistanceAndTime(bt,0,av,0,0,l9/2)StrongBrakes=true;if ll<=a8+bt*ko/2 and bs:project_on_plane(bu):normalize():dot(kj:project_on_plane(bu):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;R=true;al=false;an=true;Autopilot=false;cu()end end;LastDistanceToTarget=ll end end end;if ar==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(am or IntoOrbit or Reentry)then if not bj and not IntoOrbit then bh=HoldAltitude;bg=true;if VectorToTarget then bf.VectorToTarget=true end;cp()VectorToTarget=false;bd=true end end;if b3 and ar>0.01 and ao==-1 and bt>minRollVelocity and VectorStatus~="Finalizing Approach"then kd(bs)kX=q(bC-kq,bC-PitchStallAngle*0.80,bC+PitchStallAngle*0.80)end;U=lh;local k1=-1;if BrakeLanding then kX=0;local ls=false;local lt=30;if aU~=nil and aU>0 then local lu=q(ar,0.4,2)local l9=LastMaxBrakeInAtmo*q(bt/100,0.1,1)*lu;local lv=aU*lu+l9-j5;local lw=l9/2-j5;local lx=bt-x(c(lw/2)*20/(0.5*av))*utils.sign(lw)if lx<0 then lx=0 end;local ly;if bt>100 then local lz,_=aT.computeDistanceAndTime(bt,100,av,0,0,l9)local lA,_=aT.computeDistanceAndTime(100,0,av,0,0,x(l9))ly=lz+lA else ly=aT.computeDistanceAndTime(bt,0,av,0,0,x(l9))end;if ly<20 then BrakeIsOn=false else local lB=0;if lx>100 then local lC,_=aT.computeDistanceAndTime(lx,100,av,0,0,lv)local lD,_=aT.computeDistanceAndTime(100,0,av,0,0,aU*lu+x(l9)-j5)lB=lC+lD else lB,_=aT.computeDistanceAndTime(lx,0,av,0,0,aU*lu+x(l9)-j5)end;lB=(lB+15+bt*ko)*1.1;local lE=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if lE then local kv=planet:getAltitude(CustomTarget.position)local lF=as-kv-100;local kj=CustomTarget.position-bw;local lG=x(kj:len()^2-(as-kv)^2)if lG>100 then lE=false elseif lF<=lB or lB==-1 then BrakeIsOn=true;ls=true else BrakeIsOn=false;ls=true end end;if not lE and CalculateBrakeLandingSpeed then if lB>=lt then BrakeIsOn=true else BrakeIsOn=false end;ls=true end end end;if not bB then ce(0)end;r:setTargetGroundAltitude(500)r:activateGroundEngineAltitudeStabilization(500)stablized=true;k1=ao;if k1>-1 then b1=autoRollPreference;if bt<1 or bs:normalize():dot(bu)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;if S then a.control.extendLandingGears()bW("grOut","LG",1)end;r:setTargetGroundAltitude(LandingGearGroundHeight)af=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and bs:normalize():dot(-g_)<0.999 then BrakeIsOn=true elseif bv<-brakeLandingRate and not ls then BrakeIsOn=true elseif not ls then BrakeIsOn=false end end;if AutoTakeoff or am then local bR,bT,bS;if AutopilotTargetCoords~=nil then bR,bT,bS=aS:getPlanetarySystem(0):castIntersections(bw,(AutopilotTargetCoords-bw):normalize(),function(bU)return bU.radius+bU.noAtmosphericDensityAltitude end)end;if bz then if as>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;ce(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif c(kX)<15 and as/HoldAltitude>0.75 then AutoTakeoff=false;if not am then if bB and not AtmoSpeedAssist then a.control.cancelCurrentControlMasterMode()end elseif am and bt<Q then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;ce(0)elseif am then ce(0)BrakeIsOn=true end elseif am and ar==0 and ac~=nil and(bR==nil or bR.name==ac.name)then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;if not bB then ce(0)end;AutopilotAccelerating=true end end;local lH=ao>-1;local lI=bC;if(VectorToTarget or am or bK)and not lH and bt>minRollVelocity and ar>0.01 then local ln=math.rad(c(bD))lI=bC*c(math.cos(ln))+kq*math.sin(ln)end;local lJ=q(kX-lI,-PitchStallAngle*0.80,PitchStallAngle*0.80)if ar<0.01 and VectorToTarget then lJ=q(kX-lI,-85,MaxPitch)elseif ar<0.01 then lJ=q(kX-lI,-MaxPitch,MaxPitch)end;if c(bD)<5 or VectorToTarget or bK or BrakeLanding or lH or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(lJ)local kY=pitchPID:get()U=U+kY end end;if antigrav~=nil and(antigrav and not ExternalAGG and as<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end;ao=jX()return jO end;local function lK(lL,eA,hH)local function lM(eA)local A=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cV='::pos{'..A..','..A..','..A..','..A..','..A..'}'local d7,d8,de,df,dg=n(eA,cV)if d7=="0"and d8=="0"then return vec3(y(de),y(df),y(dg))end;df=math.rad(df)de=math.rad(de)local planet=aN[y(d7)][y(d8)]local e1=math.cos(de)local lN=vec3(e1*math.cos(df),e1*math.sin(df),math.sin(de))return planet.center+(planet.radius+dg)*lN end;local position=lM(eA)return aX.AddNewLocation(lL,position,hH)end;local function lO(p)local hH=true;local lL=".MPNAV_ROUTE"local eA=p;lK(lL,eA,hH)AutopilotTargetIndex=1;cr()system.print('Destination set to waypoint #'..currentWayPoint..' ('..p..')')end;local function lP()if currentWayPoint==#wpList then mprnStatus='OFF'end;if lastBrakeLanding==true and BrakeLanding==false then MPRN_NextTarget()end;if lastAutopilotBraking==true and AutopilotBraking==false then MPRN_NextTarget()end;lastBrakeLanding=BrakeLanding;lastAutopilotBraking=AutopilotBraking end;function MPRN_NextTarget()if mprnStatus=='ON'then currentWayPoint=currentWayPoint+1;lO(wpList[currentWayPoint])ce(100)if BrakeIsOn==true then ct()end;if GearExtended==true then a.control.retractLandingGears()r:setTargetGroundAltitude(TargetHoverHeight)end end end;local function lQ()system.updateData(mprn_data_status,'{"label": "Status", "value": "'..mprnStatus..'", "unit": ""}')system.updateData(mprn_data_wp,'{"label": "Waypoint", "value": "'..currentWayPoint..' of '..#wpList..'", "unit": ""}')system.updateData(mprn_data_vectorstatus,'{"label": "VectorStatus", "value": "'..tostring(VectorStatus)..'", "unit": ""}')system.updateData(mprn_data_BrakeLanding,'{"label": "BrakeLanding", "value": "'..tostring(BrakeLanding)..'", "unit": ""}')system.updateData(mprn_data_AutopilotTargetIndex,'{"label": "AutopilotTargetIndex", "value": "'..tostring(AutopilotTargetIndex)..'", "unit": ""}')system.updateData(mprn_data_GearExtended,'{"label": "GearExtended", "value": "'..tostring(GearExtended)..'", "unit": ""}')system.updateData(mprn_data_AutopilotBraking,'{"label": "AutopilotBraking", "value": "'..tostring(AutopilotBraking)..'", "unit": ""}')end;function script.onStart()mprn_panel=system.createWidgetPanel("Multi-Point Route Nav")mprn_widget=system.createWidget(mprn_panel,"value")mprn_data_status=system.createData('{"label": "Status", "value": "'..mprnStatus..'", "unit": ""}')system.addDataToWidget(mprn_data_status,mprn_widget)mprn_data_wp=system.createData('{"label": "Waypoint", "value": "'..currentWayPoint..' of '..#wpList..'", "unit": ""}')system.addDataToWidget(mprn_data_wp,mprn_widget)mprn_data_vectorstatus=system.createData('{"label": "VectorStatus", "value": "'..tostring(VectorStatus)..'", "unit": ""}')system.addDataToWidget(mprn_data_vectorstatus,mprn_widget)mprn_data_BrakeLanding=system.createData('{"label": "BrakeLanding", "value": "'..tostring(BrakeLanding)..'", "unit": ""}')system.addDataToWidget(mprn_data_BrakeLanding,mprn_widget)mprn_data_AutopilotTargetIndex=system.createData('{"label": "AutopilotTargetIndex", "value": "'..tostring(AutopilotTargetIndex)..'", "unit": ""}')system.addDataToWidget(mprn_data_AutopilotTargetIndex,mprn_widget)mprn_data_GearExtended=system.createData('{"label": "GearExtended", "value": "'..tostring(GearExtended)..'", "unit": ""}')system.addDataToWidget(mprn_data_GearExtended,mprn_widget)mprn_data_AutopilotBraking=system.createData('{"label": "AutopilotBraking", "value": "'..tostring(AutopilotBraking)..'", "unit": ""}')system.addDataToWidget(mprn_data_AutopilotBraking,mprn_widget)local lR={}local lS={}local lT=false;local function lU()local function lV(lW)local lX=dbHud_1.hasKey;for cF,cG in pairs(lW)do if lX(cG)then local cX=f(dbHud_1.getStringValue(cG))if cX~=nil then _G[cG]=cX;lT=true end end end end;if dbHud_1 then if not useTheseSettings then lV(c1())coroutine.yield()lV(b)else lV(b)a2="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ai=5;lT=false end;coroutine.yield()if lT then a2="Loaded Saved Variables"aG=ResolutionX;aH=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)b1=autoRollPreference;b8=AtmoSpeedLimit;ay=[[rgb(]]..d(H+0.5)..","..d(J+0.5)..","..d(I+0.5)..[[)]]az=[[rgb(]]..d(H*0.9+0.5)..","..d(J*0.9+0.5)..","..d(I*0.9+0.5)..[[)]]elseif not useTheseSettings then a2="No Saved Variables Found - Exit HUD to save settings"end else a2="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;if LastStartTime+180<D then LastMaxBrakeInAtmo=0 end;LastStartTime=D;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then a2="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ai=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;antigrav.setBaseAltitude(AntigravTargetAltitude)end;VectorStatus="Proceeding to Waypoint"end;local function lY()local function lZ(l_,m0)if l_>m0 then m0=l_ end;local m1,m2=0,0;if ContainerOptimization>0 then m1=ContainerOptimization*0.05 end;if FuelTankOptimization>0 then m2=FuelTankOptimization*0.05 end;m0=m0*(1-(m1+m2))return m0 end;local m3=core.getElementNameById;local m4=fuelX~=0 and fuelY~=0;for cF in pairs(at)do local type=core.getElementTypeById(at[cF])if n(type,'^.*Atmospheric Engine$')then if n(tostring(core.getElementTagsById(at[cF])),'^.*vertical.*$')then by=true end end;if n(type,'^.*Space Engine$')then bm=true;if n(tostring(core.getElementTagsById(at[cF])),'^.*vertical.*$')then local m5=core.getElementRotationById(at[cF])if m5[4]<0 then if z(-m5[4],0.1)==0.5 then bk=true end else if z(m5[4],0.1)==0.5 then bl=true end end end end;if type=="Landing Gear"then S=true end;if type=="Dynamic Core Unit"then local m6=h(at[cF])if m6>10000 then F=128;G=110 elseif m6>1000 then F=64;G=55 elseif m6>150 then F=32;G=27 end end;aL=aL+h(at[cF])if m4 and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local m6=h(at[cF])local jb=k(at[cF])local l_=0;local gP=o()if type=="Atmospheric Fuel Tank"then local m0=400;local m7=35.03;if m6>10000 then m0=51200;m7=5480 elseif m6>1300 then m0=6400;m7=988.67 elseif m6>150 then m0=1600;m7=182.67 end;l_=jb-m7;if fuelTankHandlingAtmo>0 then m0=m0+m0*fuelTankHandlingAtmo*0.2 end;m0=lZ(l_,m0)aI[#aI+1]={at[cF],m3(at[cF]),m0,m7,l_,gP}end;if type=="Rocket Fuel Tank"then local m0=320;local m7=173.42;if m6>65000 then m0=40000;m7=25740 elseif m6>6000 then m0=5120;m7=4720 elseif m6>700 then m0=640;m7=886.72 end;l_=jb-m7;if fuelTankHandlingRocket>0 then m0=m0+m0*fuelTankHandlingRocket*0.1 end;m0=lZ(l_,m0)aK[#aK+1]={at[cF],m3(at[cF]),m0,m7,l_,gP}end;if type=="Space Fuel Tank"then local m0=2400;local m7=182.67;if m6>10000 then m0=76800;m7=5480 elseif m6>1300 then m0=9600;m7=988.67 end;l_=jb-m7;if fuelTankHandlingSpace>0 then m0=m0+m0*fuelTankHandlingSpace*0.2 end;m0=lZ(l_,m0)aJ[#aJ+1]={at[cF],m3(at[cF]),m0,m7,l_,gP}end end end;if not by then VertTakeOff,VertTakeOffEngine=false,false end end;local function m8()if gyro~=nil then ax=gyro.getState()==1 end;if not stablized then r:deactivateGroundEngineAltitudeStabilization()end;if userControlScheme~="keyboard"then v(1)else v(0)end;if door and(aq or not aq and as<10000)then for _,cG in pairs(door)do cG.toggle()end end;if switch then for _,cG in pairs(switch)do cG.toggle()end end;if forcefield and(aq or not aq==0 and as<10000)then for _,cG in pairs(forcefield)do cG.toggle()end end;if antigrav then bz=antigrav.getState()==1;if bz and not ExternalAGG then antigrav.show()end end;if l()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if S then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if ao~=-1 or not aq and br:len()<50 then BrakeIsOn=true;GearExtended=true;if S then a.control.extendLandingGears()end else BrakeIsOn=false end;r:setTargetGroundAltitude(b2)if aq and ao~=-1 then aU=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=aq end;local function m9(ma,mb,mc,md,c9,ca,me,mf,mg,mh)local mi={enableName=ma,disableName=mb,width=mc,height=md,x=c9,y=ca,toggleVar=me,toggleFunction=mf,drawCondition=mg,hovered=false}if mh then table.insert(lS,mi)else table.insert(lR,mi)end;return mi end;local function mj(mk)if not bE then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif mk=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif mk=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif mk=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then bF=c1(mk)showHud=false else bF={}showHud=true end end;local function ml()bE=not bE;if bE then aF=lS;a2="Hold SHIFT to see Settings"bG=showHud else aF=lR;a2="Hold SHIFT to see Control Buttons"mj()showHud=bG end end;local function mm(cG)_G[cG]=not _G[cG]if _G[cG]then a2=cG.." set to true"else a2=cG.." set to false"end;if cG=="showHud"then bG=_G[cG]elseif cG=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault elseif cG=="Cockpit"then system.showScreen(0)dbHud_1.setStringValue("content","")end end;local function mn()local mo=50;local mp=340;local c9=500;local ca=aH/2-400;local mq=0;for cF,cG in pairs(c1("boolean"))do if type(_G[cG])=="boolean"then m9(cG,cG,mp,mo,c9,ca,function()return _G[cG]end,function()mm(cG)end,function()return true end,true)ca=ca+mo+20;if mq==9 then c9=c9+mp+20;ca=aH/2-400;mq=0 else mq=mq+1 end end end;m9("Control View","Control View",mp,mo,10,aH/2-500,function()return true end,ml,function()return true end,true)m9("View Handling Settings",'Hide Handling Settings',mp,mo,10,aH/2-(500-mo),function()return showHandlingVariables end,function()mj("handling")end,function()return true end,true)m9("View Hud Settings",'Hide Hud Settings',mp,mo,10,aH/2-(500-mo*2),function()return showHudVariables end,function()mj("hud")end,function()return true end,true)m9("View Physics Settings",'Hide Physics Settings',mp,mo,10,aH/2-(500-mo*3),function()return showPhysicsVariables end,function()mj("physics")end,function()return true end,true)end;local function mr()local function jH()local position=bw;local fY=planet.name..". "..#SavedLocations;if radar_1 then local dp,_=radar_1.getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dp~=nil and dp~=""then fY=fY.." "..radar_1.getConstructName(dp)end end;return aX.AddNewLocation(fY,position,false,true)end;local function ms()TurnBurn=not TurnBurn end;local function mt(mu)if mu==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;a0=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function mv()aX.UpdatePosition()end;local function jG()aX.ClearCurrentPosition()end;local function mw()local fY=AutopilotTargetName;if fY==nil then local ik=cl((bw-CustomTarget.position):len())fY=CustomTarget.name.." "..ik end;if fY==nil then fY="None"end;return"Engage Autopilot: "..fY end;local function mx()local fY=AutopilotTargetName;if fY==nil then fY=CustomTarget.name end;if fY==nil then fY="None"end;return"Disable Autopilot: "..fY end;local function my()if l()==1 then a0=not a0;if a0 then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;a.control.retractLandingGears()r:setTargetGroundAltitude(TargetHoverHeight)bW("folOn","F")else bW("folOff","F")BrakeIsOn=true;b1=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then a.control.extendLandingGears()r:setTargetGroundAltitude(LandingGearGroundHeight)end end else a2="Follow Mode only works with Remote controller"a0=false end end;local mo=50;local mp=260;local mz=m9("Enable Brake Toggle","Disable Brake Toggle",mp,mo,aG/2-mp/2,aH/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then a2="Brakes in Toggle Mode"else a2="Brakes in Default Mode"end end)m9("Align Prograde","Disable Prograde",mp,mo,aG/2-mp/2-50-mz.width,aH/2-mo+380,function()return ProgradeIsOn end,function()mt(1)end)m9("Align Retrograde","Disable Retrograde",mp,mo,aG/2-mp/2+mz.width+50,aH/2-mo+380,function()return RetrogradeIsOn end,mt,function()return ar==0 end)local mA=m9(mw,mx,600,60,aG/2-600/2,aH/2-60/2-400,function()return Autopilot end,cr)m9("Save Position","Save Position",200,mA.height,mA.x+mA.width+30,mA.y,function()return false end,jH,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)m9("Update Position","Update Position",200,mA.height,mA.x+mA.width+30,mA.y,function()return false end,mv,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)m9("Clear Position","Clear Position",200,mA.height,mA.x-200-30,mA.y,function()return true end,jG,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)mo=60;mp=300;local c9=10;local ca=aH/2-500;ca=ca+mo+20;m9("View Settings","View Settings",mp,mo,c9,ca,function()return true end,ml)local ca=aH/2-300;m9("Enable Turn and Burn","Disable Turn and Burn",mp,mo,c9,ca,function()return TurnBurn end,ms)m9("Horizontal Takeoff Mode","Vertical Takeoff Mode",mp,mo,c9+mp+20,ca,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then a2="Vertical Takeoff Mode"else a2="Horizontal Takeoff Mode"end end,function()return by end)ca=ca+mo+20;m9("Show Orbit Display","Hide Orbit Display",mp,mo,c9,ca,function()return DisplayOrbit end,function()DisplayOrbit=not DisplayOrbit;if DisplayOrbit then a2="Orbit Display Enabled"else a2="Orbit Display Disabled"end end)m9("Engage Orbiting","Cancel Orbiting",mp,mo,c9+mp+20,ca,function()return IntoOrbit end,cp,function()return ar==0 and bM end)ca=ca+mo+20;m9("Glide Re-Entry","Cancel Glide Re-Entry",mp,mo,c9,ca,function()return Reentry end,function()al=1;mt(1)end,function()return planet.hasAtmosphere and not aq end)m9("Parachute Re-Entry","Cancel Parachute Re-Entry",mp,mo,c9+mp+20,ca,function()return Reentry end,cu,function()return planet.hasAtmosphere and not aq end)ca=ca+mo+20;m9("Engage Follow Mode","Disable Follow Mode",mp,mo,c9,ca,function()return a0 end,my,function()return l()==1 end)m9("Enable Repair Arrows","Disable Repair Arrows",mp,mo,c9+mp+20,ca,function()return aM end,function()aM=not aM;if aM then a2="Repair Arrows Enabled"else a2="Repair Arrows Diabled"end end,function()return l()==1 end)ca=ca+mo+20;if not ExternalAGG then m9("Enable AGG","Disable AGG",mp,mo,c9,ca,function()return bz end,cv,function()return antigrav~=nil end)end;m9(function()return e("Switch IPH Mode - Current: %s",iphCondition)end,function()return e("IPH Mode: %s",iphCondition)end,mp*2,mo,c9,ca,function()return false end,function()if iphCondition=="All"then iphCondition="Custom Only"elseif iphCondition=="Custom Only"then iphCondition="No Moons"else iphCondition="All"end;a2="IPH Mode: "..iphCondition end)ca=ca+mo+20;m9(function()return e("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return e("Control Scheme: %s",userControlScheme)end,mp*2,mo,c9,ca,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end;a2="New Control Scheme: "..userControlScheme end)end;SetupComplete=false;beginSetup=coroutine.create(function()r:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})lU()coroutine.yield()lY()coroutine.yield()aY=jN()m8()mn()mr()aF=lR;coroutine.yield()aN=cH()aR=cI()aS=aR(cH())aT=e4()aV=ey()aZ=eW()aW=g7()aX=ju()coroutine.yield()unit.hide()system.showScreen(1)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("radarTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)unit.setTimer("fiveSecond",5)bW("start","SU")end)coroutine.resume(beginSetup)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(ar>0 or ar==0 and as<10000)then for _,cG in pairs(door)do cG.toggle()end end;if switch then for _,cG in pairs(switch)do cG.toggle()end end;if forcefield and(ar>0 or ar==0 and as<10000)then for _,cG in pairs(forcefield)do cG.toggle()end end;cB()if button then button.activate()end;if SetWaypointOnExit then aY.showWayPoint(planet,bw)end;bW("stop","SU")end;function script.onTick(mB)local mC=nil;if mB=="contact"then if not contactTimer then contactTimer=0 end;if D>contactTimer+10 then a2="Radar Contact"bW("rdrCon","RC")contactTimer=D end;unit.stopTimer("contact")elseif mB=="tenthSecond"then lQ()local function mD()local mE=system.createData;local mF=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=mF(panelInterplanetary,"value")interplanetaryHeaderText=mE('{"label": "Target Planet", "value": "N/A", "unit":""}')u(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=mF(panelInterplanetary,"value")widgetDistanceText=mE('{"label": "distance", "value": "N/A", "unit":""}')u(widgetDistanceText,widgetDistance)widgetTravelTime=mF(panelInterplanetary,"value")widgetTravelTimeText=mE('{"label": "Travel Time", "value": "N/A", "unit":""}')u(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=mF(panelInterplanetary,"value")widgetMaxMassText=mE('{"label": "Maximum Mass", "value": "N/A", "unit":""}')u(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=mF(panelInterplanetary,"value")widgetTargetOrbitText=mE('{"label": "Target Altitude", "value": "N/A", "unit":""}')u(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=mF(panelInterplanetary,"value")widgetCurBrakeDistanceText=mE('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=mF(panelInterplanetary,"value")widgetCurBrakeTimeText=mE('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=mF(panelInterplanetary,"value")widgetMaxBrakeDistanceText=mE('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=mF(panelInterplanetary,"value")widgetMaxBrakeTimeText=mE('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=mF(panelInterplanetary,"value")widgetTrajectoryAltitudeText=mE('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not aq then u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)u(widgetCurBrakeTimeText,widgetCurBrakeTime)u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function mG()s(panelInterplanetary)panelInterplanetary=nil end;local function mH()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(ac.center-bw):len()else AutopilotDistance=(CustomTarget.position-bw):len()end end;local ew=bt;local k_=unit.getThrottle()/100;if AtmoSpeedAssist then k_=K end;local mI,mJ=aT.computeDistanceAndTime(bt,MaxGameVelocity,av,a:maxForceForward()*k_,warmup,0)local a8,a9;if not TurnBurn then a8,a9=aY.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a8,a9=aY.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,mK;if not TurnBurn and ew>0 then _,mK=aY.GetAutopilotBrakeDistanceAndTime(ew)else _,mK=aY.GetAutopilotTBBrakeDistanceAndTime(ew)end;local mL=0;local mM=0;if AutopilotCruising or not Autopilot and ew>5 then mM=aT.computeTravelTime(ew,0,AutopilotDistance)elseif a8+mI<AutopilotDistance then mL=AutopilotDistance-(a8+mI)mM=aT.computeTravelTime(8333.0556,0,mL)else local mN=(AutopilotDistance-a8)/mI;mI=AutopilotDistance-a8;mJ=mJ*mN end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return mM elseif AutopilotBraking then return mK elseif AutopilotCruising then return mM+mK else return mJ+a9+mM end end;local function mO(j5,mP)if j5==nil then j5=core.g()end;j5=z(j5,5)if mP~=nil and mP or(mC==nil or mC~=j5)then local ew=br:len()local mQ=f(unit.getData()).maxBrake;if mQ~=nil and mQ>0 and aq then mQ=mQ/q(ew/100,0.1,1)mQ=mQ/ar;if ar>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+mQ)/2 else LastMaxBrakeInAtmo=mQ end end end;if mQ~=nil and mQ>0 then LastMaxBrake=mQ end;mC=j5 end end;mO(nil,true)if bA~=nil then if r:getTargetSpeed(axisCommandId.longitudinal)~=bA then ch(bA,TRUE)else bA=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then mD()end;if AutopilotTargetName~=nil then local mR=CustomTarget~=nil;local mS=0.5*LastMaxBrakeInAtmo/ac:getGravity(ac.center+vec3(0,0,1)*ac.radius):len()mS=mS>1000000 and z(mS/1000000,2).." kTons"or z(mS/1000,2).." Tons"t(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=mH()if mR and not Autopilot then aj=(bw-CustomTarget.position):len()else aj=(AutopilotTargetCoords-bw):len()end;if not TurnBurn then a8,a9=aY.GetAutopilotBrakeDistanceAndTime(bt)aa,ab=aY.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a8,a9=aY.GetAutopilotTBBrakeDistanceAndTime(bt)aa,ab=aY.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local ik=cl(aj)t(widgetDistanceText,'{"label": "distance", "value": "'..ik..'"}')t(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..cw(travelTime)..'", "unit":""}')ik=cl(a8)t(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..ik..'"}')t(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..cw(a9)..'", "unit":""}')ik=cl(aa)t(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..ik..'"}')t(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..cw(ab)..'", "unit":""}')t(widgetMaxMassText,'{"label": "Max Brake Mass", "value": "'..e("%s",mS)..'", "unit":""}')ik=cl(AutopilotTargetOrbit)t(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..ik..'"}')if ar>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true;if not bB and AtmoSpeedAssist and(AltitudeHold or Reentry or an)then ce(1)BrakeIsOn=false;O=false end end;if ar==0 and WasInAtmo then if t(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if t(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if t(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then u(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if t(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if t(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else mG()end;if warpdrive~=nil then if f(warpdrive.getData()).destination~="Unknown"and f(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end;aW.DrawTanks()if shield_1 then aW.DrawShield()end elseif mB=="oneSecond"then local function mT(gW)local mU=0;aD=""local mV=aL;local mW=0;local mX=0;local mY=0;local gT=0;local gU=""local mZ=core.getElementHitPointsById;for cF in pairs(at)do local m6=0;local m_=0;m_=h(at[cF])m6=mZ(at[cF])mW=mW+m6;if m6<m_ then if m6==0 then mY=mY+1 else mX=mX+1 end;if aM and#aA==0 then position=vec3(core.getElementPositionById(at[cF]))local c9=position.x-F;local ca=position.y-F;local fq=position.z-F;table.insert(aA,core.spawnArrowSticker(c9,ca,fq+1,"down"))table.insert(aA,core.spawnArrowSticker(c9,ca,fq+1,"down"))core.rotateSticker(aA[2],0,0,90)table.insert(aA,core.spawnArrowSticker(c9+1,ca,fq,"north"))table.insert(aA,core.spawnArrowSticker(c9+1,ca,fq,"north"))core.rotateSticker(aA[4],90,90,0)table.insert(aA,core.spawnArrowSticker(c9-1,ca,fq,"south"))table.insert(aA,core.spawnArrowSticker(c9-1,ca,fq,"south"))core.rotateSticker(aA[6],90,-90,0)table.insert(aA,core.spawnArrowSticker(c9,ca-1,fq,"east"))table.insert(aA,core.spawnArrowSticker(c9,ca-1,fq,"east"))core.rotateSticker(aA[8],90,0,90)table.insert(aA,core.spawnArrowSticker(c9,ca+1,fq,"west"))table.insert(aA,core.spawnArrowSticker(c9,ca+1,fq,"west"))core.rotateSticker(aA[10],-90,0,90)table.insert(aA,at[cF])end elseif aM and#aA>0 and aA[11]==at[cF]then for gO in pairs(aA)do core.deleteSticker(aA[gO])end;aA={}end end;mU=d(mW/mV*100)if mU<100 then gW[#gW+1]=c8(0,0,"","pbright txt")gT=d(mU*2.55)gU=e("rgb(%d,%d,%d)",255-gT,gT,0)if mU<100 then gW[#gW+1]=c8("50%",1035,"Elemental Integrity: "..mU.."%","txtbig txtmid","fill:"..gU)if mY>0 then gW[#gW+1]=c8("50%",1055,"Disabled Modules: "..mY.." Damaged Modules: "..mX,"txtbig txtmid","fill:"..gU)elseif mX>0 then gW[#gW+1]=c8("50%",1055,"Damaged Modules: "..mX,"txtbig txtmid","fill:"..gU)end end end end;local function n0()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then s(WeaponPanelID)WeaponPanelID=nil end end end;local function n1()local gP=o()local i7=bt;local n2=gP-au;if i7>1.38889 then i7=i7/1000;local n3=i7*(gP-au)TotalDistanceTravelled=TotalDistanceTravelled+n3;ad=ad+n3 end;ae=ae+n2;TotalFlightTime=TotalFlightTime+n2;au=gP end;n1()aW.UpdatePipe()passengers=core.getPlayersOnBoard()ships=core.getDockedConstructs()n0()local gW={}aW.ExtraData(gW)if ShowOdometer then gW=aW.DrawOdometer(gW,ad,TotalDistanceTravelled,ae)end;if ShouldCheckDamage then mT(gW)end;ak=table.concat(gW,"")collectgarbage("collect")elseif mB=="fiveSecond"then if not UseSatNav then return end;ap=dbHud_1.getStringValue("SPBAutopilotTargetName")if ap~=nil and ap~=""and ap~="SatNavNotChanged"then local cX=f(dbHud_1.getStringValue("SavedLocations"))if cX~=nil then _G["SavedLocations"]=cX;local fJ=-1;local jK;for cF,cG in pairs(SavedLocations)do if cG.name and cG.name=="SatNav Location"then fJ=cF;break end end;if fJ~=-1 then jK=SavedLocations[fJ]fJ=-1;for cF,cG in pairs(aN[0])do if cG.name and cG.name=="SatNav Location"then fJ=cF;break end end;if fJ>-1 then aN[0][fJ]=jK end;aX.UpdateAtlasLocationsList()a2=jK.name.." position updated"end end;for i=1,#bH do if bH[i].name==ap then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..bH[i].name)aX.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif mB=="msgTick"then local gW={}aW.DisplayMessage(gW,"empty")a2="empty"unit.stopTimer("msgTick")ai=3 elseif mB=="animateTick"then b0=true;a_=false;ag=0;ah=0;unit.stopTimer("animateTick")elseif mB=="hudTick"then local function n4(gW)local n5=d(q(aj/(aG/4)*255,0,255))gW[#gW+1]=e("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",ag,ah,d(H+0.5)+n5,d(J+0.5)-n5,d(I+0.5)-n5)end;local function n6()for _,cG in pairs(aF)do if cG.hovered then if not cG.drawCondition or cG.drawCondition()then cG.toggleFunction()end;cG.hovered=false end end end;local function n7()local function n8(n9,na,c9,ca,mc,md)if n9>c9 and n9<c9+mc and na>ca and na<ca+md then return true else return false end end;local c9=ag+aG/2;local ca=ah+aH/2;for _,cG in pairs(aF)do cG.hovered=n8(c9,ca,cG.x,cG.y,cG.width,cG.height)end end;local function nb(gW)local function nc(gW,nd,hover,c9,ca,ep,ne,nf,ng,nh,ni)if type(nh)=="function"then nh=nh()end;if type(ni)=="function"then ni=ni()end;gW[#gW+1]=e("<rect x='%f' y='%f' width='%f' height='%f' fill='",c9,ca,ep,ne)if nd then gW[#gW+1]=e("%s'",nf)else gW[#gW+1]=ng end;if hover then gW[#gW+1]=" style='stroke:white; stroke-width:2'"else gW[#gW+1]=" style='stroke:black; stroke-width:1'"end;gW[#gW+1]="></rect>"gW[#gW+1]=e("<text x='%f' y='%f' font-size='24' fill='",c9+ep/2,ca+ne/2+5)if nd then gW[#gW+1]="black"else gW[#gW+1]="white"end;gW[#gW+1]="' text-anchor='middle' font-family='Montserrat'>"if nd then gW[#gW+1]=e("%s</text>",nh)else gW[#gW+1]=e("%s</text>",ni)end end;local nj="rgb(50,50,50)'"local nk="rgb(210,200,200)"local nl=nc;for _,cG in pairs(aF)do local mb=cG.disableName;local ma=cG.enableName;if type(mb)=="function"then mb=mb()end;if type(ma)=="function"then ma=ma()end;if not cG.drawCondition or cG.drawCondition()then nl(gW,cG.toggleVar(),cG.hovered,cG.x,cG.y,cG.width,cG.height,nk,nj,mb,ma)end end end;local nm=z(ResolutionX/2,0)local nn=z(ResolutionY/2,0)local gW={}aW.HUDPrologue(gW)if showHud then aW.UpdateHud(gW)else if AlwaysVSpd then aW.DrawVerticalSpeed(gW,as)end;aW.DisplayOrbitScreen(gW)aW.DrawWarnings(gW)end;if bE and bF~={}then aW.DrawSettings(gW)end;if radar_1 then aW.DrawRadarInfo()end;aW.HUDEpilogue(gW)gW[#gW+1]=e([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],aG,aH)if a2~="empty"then aW.DisplayMessage(gW,a2)end;if l()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then aW.DrawDeadZone(gW)end end;if w()==0 then if l()==1 and a1 then if not AltIsOn then n7()nb(gW)end;if not a_ and not b0 then local no=table.concat(gW,"")gW={}gW[#gW+1]=e("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aG,aH)gW[#gW+1]=no;gW[#gW+1]="</body>"a_=true;gW[#gW+1]=[[</svg></body>]]unit.setTimer("animateTick",0.5)local content=table.concat(gW,"")system.setScreen(content)elseif b0 then local no=table.concat(gW,"")gW={}gW[#gW+1]=e("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aG,aH)gW[#gW+1]=no;gW[#gW+1]="</body>"end;if not a_ then gW[#gW+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],nm,nn,ag,ah)end else n6()end else if not a1 and l()==0 then n6()if aj>DeadZone then if DisplayDeadZone then n4(gW)end end elseif not AltIsOn or AltIsOn and a1 then n7()nb(gW)end;gW[#gW+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],nm,nn,ag,ah)end;gW[#gW+1]=[[</svg></body>]]content=table.concat(gW,"")elseif mB=="apTick"then aY.APTick()elseif mB=="radarTick"then aZ.UpdateRadar()elseif mB=="tagTick"then if UseExtra=="Off"then UseExtra="All"elseif UseExtra=="All"then UseExtra="Longitude"elseif UseExtra=="Longitude"then UseExtra="Lateral"elseif UseExtra=="Lateral"then UseExtra="Vertical"else UseExtra="Off"end;a2="Extra Engine Tags: "..UseExtra;unit.stopTimer("tagTick")end end;function script.onFlush()local function np(nq,l7)local nr=vec3()local ns=vec3()if nq==axisCommandId.longitudinal then nr=vec3(core.getConstructOrientationForward())ns=bp elseif nq==axisCommandId.vertical then nr=vec3(core.getConstructOrientationUp())ns=bo elseif nq==axisCommandId.lateral then nr=vec3(core.getConstructOrientationRight())ns=bq else return vec3()end;local nt=vec3(core.getWorldGravity())local nu=nt:dot(ns)local nw=vec3(core.getWorldAirFrictionAcceleration())local nx=nw:dot(ns)local ny=br:dot(nr)local nz=l7*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(nz-ny)local nA=targetSpeedPID2:get()local nB=(nA-nx-nu)*ns;return nB end;local function nC(nq,l7)local nr=vec3()local ns=vec3()if nq==axisCommandId.longitudinal then nr=vec3(core.getConstructOrientationForward())ns=bp elseif nq==axisCommandId.vertical then nr=vec3(core.getConstructOrientationUp())ns=bo elseif nq==axisCommandId.lateral then nr=vec3(core.getConstructOrientationRight())ns=bq else return vec3()end;local nt=vec3(core.getWorldGravity())local nu=nt:dot(ns)local nw=vec3(core.getWorldAirFrictionAcceleration())local nx=nw:dot(ns)local ny=br:dot(nr)local nz=l7*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(nz-ny)local nA=targetSpeedPID:get()local nB=(nA-nx-nu)*ns;return nB end;local function nD(nE,gZ,jz)local nF=nE:cross(jz):normalize_inplace()local hL=math.acos(q(nF:dot(-gZ),-1,1))*constants.rad2deg;if nF:cross(-gZ):dot(jz)<0 then hL=-hL end;return hL end;if antigrav and not ExternalAGG then if not bz and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;bB=r:getAxisCommandType(0)==axisCommandType.byThrottle;if bB and O then ce(0)O=false elseif not bB and not O then K=0;O=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)local nG=q(T+U+system.getControlDeviceForwardInput(),-1,1)local nH=q(W+Z+system.getControlDeviceYawInput(),-1,1)local nI=q(X+V-system.getControlDeviceLeftRightInput(),-1,1)local nJ=Y;bu=vec3(core.getWorldVertical())if bu==nil or bu:len()==0 then bu=(planet.center-bw):normalize()end;bo=vec3(core.getConstructWorldOrientationUp())bp=vec3(core.getConstructWorldOrientationForward())bq=vec3(core.getConstructWorldOrientationRight())bs=vec3(core.getWorldVelocity())br=vec3(core.getVelocity())bw=vec3(core.getConstructWorldPos())av=core.getConstructMass()bt=vec3(bs):len()bv=-bu:dot(bs)bD=getRoll(bu,bp,bq)local nK=bD/180*math.pi;local nL=math.cos(nK)local nM=math.sin(nK)bC=nD(bu,bp,bq*nL+bo*nM)local nN=bs:normalize()local nO=c(bD)local nP=utils.sign(bD)local nQ=vec3(core.getWorldAngularVelocity())local nR=nG*pitchSpeedFactor*bq+nH*rollSpeedFactor*bp+nI*yawSpeedFactor*bo;if b1==true and bu:len()>0.01 then local nS=c(b5-bD)if((ProgradeIsOn or Reentry or BrakeLanding or al or AltitudeHold or IntoOrbit)and nS>0 or ar>0.0 and nS<autoRollRollThreshold and autoRollPreference)and nH==0 and c(bC)<85 then local nT=b5;local nU=autoRollFactor;if ar==0 then nU=nU/4;b5=0;nT=0 end;if rollPID==nil then rollPID=pid.new(nU*0.01,0,nU*0.1)end;rollPID:inject(nT-bD)local nV=rollPID:get()nR=nR+nV*bp end end;local nW=1;local nX=0;local nY=1;if system.getMouseWheel()>0 then if AltIsOn then if ar>0 or Reentry then b8=q(b8+speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=q(MaxGameVelocity+speedChangeLarge/3.6*100,0,8333.00)end elseif aw then local nZ=K;K=z(q(K+speedChangeLarge/100,-1,1),2)if K>=0 and nZ<0 then K=0;aw=false end end elseif system.getMouseWheel()<0 then if AltIsOn then if ar>0 or Reentry then b8=q(b8-speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=q(MaxGameVelocity-speedChangeLarge/3.6*100,0,8333.00)end elseif aw then local nZ=K;K=z(q(K-speedChangeLarge/100,-1,1),2)if K<=0 and nZ>0 then K=0;aw=false end end else aw=true end;L=0;if aq and AtmoSpeedAssist and bB then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(b8/3.6-bs:dot(bp))local n_=throttlePID:get()N=q(n_,-1,1)if N<K and ar>0.005 then M=true;r:setThrottleCommand(axisCommandId.longitudinal,q(N,0.01,1))else M=false;r:setThrottleCommand(axisCommandId.longitudinal,K)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bs:len()-b8/3.6)local o0=q(brakePID:get(),0,1)if ar>0 and bv<-80 or ar>0.005 then L=o0 end;if L>0 then if M and N==0.01 then r:setThrottleCommand(axisCommandId.longitudinal,0)end else N=q(N,0.01,1)end;local o1=''local o2=vec3()local o3=np(axisCommandId.vertical,af*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",o3,nX)local o4='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then o4=o4 ..ExtraLongitudeTags end;local o5=r:getAxisCommandType(axisCommandId.longitudinal)local o6=r:composeAxisAccelerationFromThrottle(o4,axisCommandId.longitudinal)local o7=nC(axisCommandId.lateral,LeftAmount*1000)o1=o1 ..' , '.."lateral airfoil , lateral ground "o2=o2+o7;if o2:len()>constants.epsilon then a:setEngineForceCommand(o1,o2,nX,'','','',nY)end;a:setEngineForceCommand(o4,o6,nW)local o8='thrust analog vertical fueled 'local o9='thrust analog lateral fueled 'if UseExtra=="All"or UseExtra=="Lateral"then o9=o9 ..ExtraLateralTags end;if UseExtra=="All"or UseExtra=="Vertical"then o8=o8 ..ExtraVerticalTags end;if af~=0 or BrakeLanding and BrakeIsOn or not GearExtended and not stablized then a:setEngineForceCommand(o8,o3,nW)else a:setEngineForceCommand(o8,vec3(),nW)end;if LeftAmount~=0 then a:setEngineForceCommand(o9,o7,nW)else a:setEngineForceCommand(o9,vec3(),nW)end;if nJ==0 then nJ=L end;local oa=-nJ*(brakeSpeedFactor*bs+brakeFlatFactor*nN)a:setEngineForceCommand('brake',oa)else if AtmoSpeedAssist then r:setThrottleCommand(axisCommandId.longitudinal,K)end;local l7=unit.getAxisCommandValue(0)if not bB then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bs:len()-l7/3.6)local o0=q(brakePID:get(),0,1)nJ=q(nJ+o0,0,1)end;local oa=-nJ*(brakeSpeedFactor*bs+brakeFlatFactor*nN)a:setEngineForceCommand('brake',oa)local o1=''local o2=vec3()local ob=false;local o4='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then o4=o4 ..ExtraLongitudeTags end;local o5=r:getAxisCommandType(axisCommandId.longitudinal)if o5==axisCommandType.byThrottle then local o6=r:composeAxisAccelerationFromThrottle(o4,axisCommandId.longitudinal)a:setEngineForceCommand(o4,o6,nW)elseif o5==axisCommandType.byTargetSpeed then local o6=r:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)o1=o1 ..' , '..o4;o2=o2+o6;if r:getTargetSpeed(axisCommandId.longitudinal)==0 or r:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-r:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then ob=true end end;local o9='thrust analog lateral 'if UseExtra=="All"or UseExtra=="Lateral"then o9=o9 ..ExtraLateralTags end;local oc=r:getAxisCommandType(axisCommandId.lateral)if oc==axisCommandType.byThrottle then local od=r:composeAxisAccelerationFromThrottle(o9,axisCommandId.lateral)a:setEngineForceCommand(o9,od,nW)elseif oc==axisCommandType.byTargetSpeed then local o7=r:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)o1=o1 ..' , '..o9;o2=o2+o7 end;local o8='thrust analog vertical 'if UseExtra=="All"or UseExtra=="Vertical"then o8=o8 ..ExtraVerticalTags end;local oe=r:getAxisCommandType(axisCommandId.vertical)if oe==axisCommandType.byThrottle then local o3=r:composeAxisAccelerationFromThrottle(o8,axisCommandId.vertical)if af~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(o8,o3,nW,'airfoil','ground','',nY)else a:setEngineForceCommand(o8,vec3(),nW)a:setEngineForceCommand('airfoil vertical',o3,nW,'airfoil','','',nY)a:setEngineForceCommand('ground vertical',o3,nW,'ground','','',nY)end elseif oe==axisCommandType.byTargetSpeed then if af<0 then a:setEngineForceCommand('hover',vec3(),nW)end;local of=r:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)o1=o1 ..' , '..o8;o2=o2+of end;if o2:len()>constants.epsilon then if Y~=0 or ob or c(nN:dot(bp))<0.8 then o1=o1 ..', brake'end;a:setEngineForceCommand(o1,o2,nX,'','','',nY)end end;local og=torqueFactor*(nR-nQ)local oh=vec3(core.getWorldAirFrictionAngularAcceleration())og=og-oh;a:setEngineTorqueCommand('torque',og,nW,'airfoil','','',nY)a:setBoosterCommand('rocket_engine')if a7 and not VanillaRockets then local ew=br:len()local oi=0.15;if not bB then local oj=r:getTargetSpeed(axisCommandId.longitudinal)if ew*3.6>oj*(1-oi)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif ew*3.6<oj*(1-oi)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local k_=unit.getThrottle()if AtmoSpeedAssist then k_=K*100 end;local l7=k_/100;if j==0 then l7=l7*MaxGameVelocity;if ew>=l7*(1-oi)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif ew<l7*(1-oi)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local li=d(b8)l7=l7*li/3.6;if ew>=l7*(1-oi)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif ew<l7*(1-oi)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local g4=coroutine.status(beginSetup)if g4=="suspended"then local cf,g5=coroutine.resume(beginSetup)if g5 then system.print("ERROR STARTUP: "..g5)end elseif g4=="dead"then SetupComplete=true end end;if SetupComplete then a:update()if not a_ and content~=LastContent then if not Cockpit then system.setScreen(content)else dbHud_1.setStringValue("content",content)end end;LastContent=content end;lP()end;function script.onActionStart(ok)local function ol(om)local C=1;local function on(oo,om)local op={planet.surfaceMaxAltitude+100,planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude,planet.noAtmosphericDensityAltitude+LowOrbitHeight,planet.radius*(TargetOrbitRadius-1)+planet.noAtmosphericDensityAltitude}local oq=oo;for _,cG in ipairs(op)do if om and oq>cG then oo=cG elseif oo<cG and not om then oo=cG;break end end;return oo end;if om then C=-1 end;if not ExternalAGG and bz then if a1 and om then AntigravTargetAltitude=1000 elseif AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+C*a4;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+C*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then if a1 then bh=on(bh,om)else bh=bh+C*a3 end;if bh<planet.noAtmosphericDensityAltitude then bh=planet.noAtmosphericDensityAltitude end else if a1 and aq then HoldAltitude=on(HoldAltitude,om)else HoldAltitude=HoldAltitude+C*a3 end end else r:updateTargetGroundAltitudeFromActionStart(C*1.0)end end;local function os(om)local C=1;if om then C=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn then K=q(K+C*speedChangeLarge/100,-1,1)else r:updateCommandFromActionStart(axisCommandId.longitudinal,C*speedChangeLarge)end else if om then C=1 else C=nil end;aX.adjustAutopilotTargetIndex(C)end end;local function ot(ou)if not aq then a2="Flight Assist in Atmo only"return end;local cN=type(ou)if bK==nil then if cN=="table"then if Autopilot or VectorToTarget then cr()end;bW("180On","BR")elseif ou==1 then bW("bnkLft","BR")else bW("bnkRht","BR")end;if not AltitudeHold and not Autopilot and not VectorToTarget then cq()if cN~="table"then ou=ou+1 end end;bK=ou else bW("180Off","BR")bK=nil end end;if ok=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;ce(0)if vBooster or hover then if aq and ao==-1 then bW("bklOn","BL")StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;b1=true;GearExtended=false else if S then bW("grOut","LG",1)a.control.extendLandingGears()end;r:setTargetGroundAltitude(LandingGearGroundHeight)if aq then BrakeIsOn=true end end end;if S and not BrakeLanding and not(vBooster or hover)then bW("grOut","LG",1)a.control.extendLandingGears()end else if S then bW("grIn","LG",1)a.control.retractLandingGears()end;r:setTargetGroundAltitude(TargetHoverHeight)end elseif ok=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif ok=="forward"then T=T-1 elseif ok=="backward"then if AltIsOn then ot(-bs*5000)else T=T+1 end elseif ok=="left"then if AltIsOn then ot(1)else W=W-1 end elseif ok=="right"then if AltIsOn then ot(3)else W=W+1 end elseif ok=="yawright"then X=X-1 elseif ok=="yawleft"then X=X+1 elseif ok=="straferight"then r:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif ok=="strafeleft"then r:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif ok=="up"then af=af+1;r:deactivateGroundEngineAltitudeStabilization()r:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif ok=="down"then af=af-1;r:deactivateGroundEngineAltitudeStabilization()r:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif ok=="groundaltitudeup"then ol()elseif ok=="groundaltitudedown"then ol(true)elseif ok=="option1"then toggleView=false;if AltIsOn and a1 then local ov=""for i=1,#passengers do ov=ov.."| Name: "..system.getPlayerName(passengers[i]).." Mass: "..z(core.getBoardedPlayerMass(passengers[i])/1000,1).."t "end;system.print("Onboard: "..ov)return end;aX.adjustAutopilotTargetIndex()elseif ok=="option2"then toggleView=false;if AltIsOn and a1 then for i=1,#passengers do core.forceDeboard(passengers[i])end;a2="Deboarded All Passengers"return end;aX.adjustAutopilotTargetIndex(1)elseif ok=="option3"then local function ow()aE=not aE;if not aE then bW("wid","DH")unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end;parentingPanelId=system.createWidgetPanel("Docking")parentingWidgetId=system.createWidget(parentingPanelId,"parenting")system.addDataToWidget(unit.getDataId(),parentingWidgetId)coreCombatStressPanelId=system.createWidgetPanel("Core combat stress")coreCombatStressgWidgetId=system.createWidget(coreCombatStressPanelId,"core_stress")system.addDataToWidget(core.getDataId(),coreCombatStressgWidgetId)if shield_1~=nil then shield_1.show()end else bW("hud","DH")unit.hide()core.hide()if fuelPanelID~=nil then s(fuelPanelID)fuelPanelID=nil end;if parentingPanelId~=nil then s(parentingPanelId)parentingPanelId=nil end;if coreCombatStressPanelId~=nil then s(coreCombatStressPanelId)coreCombatStressPanelId=nil end;if spacefuelPanelID~=nil then s(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then s(rocketfuelPanelID)rocketfuelPanelID=nil end;if shield_1~=nil then shield_1.hide()end end end;if AltIsOn and a1 then local ov=""for i=1,#ships do ov=ov.."| ID: "..ships[i].." Mass: "..z(core.getDockedConstructMass(ships[i])/1000,1).."t "end;system.print("Docked Ships: "..ov)return end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;ow()toggleView=false elseif ok=="option4"then toggleView=false;if AltIsOn and a1 then for i=1,#ships do core.forceUndock(ships[i])end;a2="Undocked all ships"return end;bK=nil;cr()elseif ok=="option5"then toggleView=false;if AltIsOn and a1 then if shield_1 then shield_1.toggle()return else a2="No shield found"return end end;function ToggleLockPitch()if LockPitch==nil then bW("lkPOn","LP")if not a1 then LockPitch=bC else LockPitch=LockPitchTarget end;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else bW("lkPOff","LP")LockPitch=nil end end;ToggleLockPitch()elseif ok=="option6"then toggleView=false;if AltIsOn and a1 then if shield_1 then local ox=shield_1.getVentingCooldown()if ox>0 then a2="Cannot vent again for "..ox.." seconds"return end;if shield_1.getShieldHitpoints()<shield_1.getMaxShieldHitpoints()then shield_1.startVenting()a2="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else a2="Shields already at max hitpoints"end;return else a2="No shield found"return end end;cq()elseif ok=="option7"then CollisionSystem=not CollisionSystem;if CollisionSystem then a2="Collision System Enabled"else a2="Collision System Secured"end;toggleView=false elseif ok=="option8"then stablized=not stablized;if not stablized then a2="DeCoupled Mode - Ground Stabilization off"r:deactivateGroundEngineAltitudeStabilization()bW("gsOff","GS")else a2="Coupled Mode - Ground Stabilization on"r:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)bW("gsOn","GS")end;toggleView=false elseif ok=="option9"then if AltIsOn and a1 then r:resetCommand(axisCommandId.longitudinal)r:resetCommand(axisCommandId.lateral)r:resetCommand(axisCommandId.vertical)ce(0)unit.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()ax=gyro.getState()==1;if ax then bW("gyOn","GA")else bW("gyOff","GA")end end;toggleView=false elseif ok=="lshift"then if AltIsOn then a1=true end;if w()==1 then a1=true;PrevViewLock=w()v(1)elseif l()==1 and ShiftShowsRemoteButtons then a1=true;b0=false;a_=false end elseif ok=="brake"then if BrakeToggleStatus then ct()elseif not BrakeIsOn then ct()else BrakeIsOn=true end elseif ok=="lalt"then toggleView=true;AltIsOn=true;if l()==0 and not freeLookToggle and userControlScheme=="keyboard"then v(1)end elseif ok=="booster"then if VanillaRockets then a:toggleBoosters()elseif not a7 then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;a7=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;a7=false end elseif ok=="stopengines"then local function oy()if D-E<1.5 then bW("clear","CA")AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;bK=nil;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;a0=false;P=false;al=false;am=false;R=false;b1=autoRollPreference;VectorToTarget=false;TurnBurn=false;ax=false;LockPitch=nil;IntoOrbit=false end end;oy()E=D;if r:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if K~=0 then r:resetCommand(axisCommandId.longitudinal)ce(0)else ce(100)end else if r:getTargetSpeed(axisCommandId.longitudinal)~=0 then r:resetCommand(axisCommandId.longitudinal)else if aq then ch(AtmoSpeedLimit)else ch(MaxGameVelocity*3.6)end end end elseif ok=="speedup"then os()elseif ok=="speeddown"then os(true)elseif ok=="antigravity"and not ExternalAGG then if antigrav~=nil then cv()end end end;function script.onActionStop(ok)local function oz()if not ExternalAGG and bz then a6=a4 end;if AltitudeHold or VertTakeOff or IntoOrbit then a5=a3 end end;if ok=="forward"then T=0 elseif ok=="backward"then T=0 elseif ok=="left"then if bK then if bK==2 then bK=-2 else bK=-1 end end;W=0 elseif ok=="right"then if bK then if bK==4 then bK=-2 else bK=-1 end end;W=0 elseif ok=="yawright"then X=0 elseif ok=="yawleft"then X=0 elseif ok=="straferight"then r:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif ok=="strafeleft"then r:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif ok=="up"then af=0;r:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if stablized then r:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif ok=="down"then af=0;r:updateCommandFromActionStop(axisCommandId.vertical,1.0)if stablized then r:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif ok=="groundaltitudeup"then oz()toggleView=false elseif ok=="groundaltitudedown"then oz()toggleView=false elseif ok=="lshift"then if w()==1 then ag=0;ah=0;v(PrevViewLock)elseif l()==1 and ShiftShowsRemoteButtons then b0=false;a_=false end;a1=false elseif ok=="brake"then if not BrakeToggleStatus then if BrakeIsOn then ct()else BrakeIsOn=false end end elseif ok=="lalt"then if l()==0 and freeLookToggle then if toggleView then if w()==1 then v(0)else v(1)end else toggleView=true end elseif l()==0 and not freeLookToggle and userControlScheme=="keyboard"then v(0)end;AltIsOn=false end end;function script.onActionLoop(ok)local function oA(om)local C=1;if om then C=-1 end;if not ExternalAGG and bz then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+C*a6;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;a6=q(a6*1.05,a4,50)BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+C*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then bh=bh+C*a5;if bh<planet.noAtmosphericDensityAltitude then bh=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+C*a5 end;a5=q(a5*1.05,a3,50)else r:updateTargetGroundAltitudeFromActionLoop(C*1.0)end end;local function oB(om)local C=1;if om then C=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn then K=q(K+C*speedChangeSmall/100,-1,1)else r:updateCommandFromActionLoop(axisCommandId.longitudinal,C*speedChangeSmall)end end end;if ok=="groundaltitudeup"then if not a1 then oA()end elseif ok=="groundaltitudedown"then if not a1 then oA(true)end elseif ok=="speedup"then oB()elseif ok=="speeddown"then oB(true)end end;function script.onInputText(cb)local function oC()for cF,cG in pairs(c1())do dbHud_1.setStringValue(cG,g(nil))end;for cF,cG in pairs(b)do if cG~="SavedLocations"then dbHud_1.setStringValue(cG,g(nil))end end;a2="Databank wiped except Save Locations. New variables will save after re-enter seat and exit"ai=5 end;local i;local oD,oE=nil,nil;local oF="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute"i=string.find(cb," ")oD=cb;if i~=nil then oD=string.sub(cb,0,i-1)oE=string.sub(cb,i+1)end;if oD=="/help"or oD=="/commands"then for jf in string.gmatch(oF,"([^\n]+)")do system.print(jf)end;return elseif oD=="/setname"then if oE==nil or oE==""then a2="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then aX.UpdatePosition(oE)else a2="Select a saved target to rename first"end elseif shield_1 and oD=="/resist"then if oE==nil or shield_1.getResistancesCooldown()>0 then a2="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local A=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cV=A..', '..A..', '..A..', '..A;local oG,oH,oI,oJ=n(oE,cV)if oJ==nil or oG+oH+oI+oJ>0.6 then a2="Improperly formatted or total exceeds 0.6"return end;if shield_1.setResistances(oG,oH,oI,oJ)==1 then a2="Shield Resistances set"else a2="Resistance setting failed."end elseif oD=="/addlocation"or string.find(cb,"::pos")~=nil then local hH=false;local lL="0-Temp"if oE==nil or oE==""then oE=oD;hH=true end;i=string.find(oE,"::")if not hH then lL=string.sub(oE,1,i-2)end;local eA=string.sub(oE,i)lK(lL,eA,hH)elseif oD=="/agg"then if oE==nil or oE==""then a2="Usage: /agg targetheight"return end;oE=y(oE)if oE<1000 then oE=1000 end;AntigravTargetAltitude=oE;a2="AGG Target Height set to "..oE elseif oD=="/G"then if oE==nil or oE==""then a2="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if oE=="dump"then for cF,cG in pairs(c1())do if type(_G[cG])=="boolean"then if _G[cG]==true then system.print(cG.." true")else system.print(cG.." false")end elseif _G[cG]==nil then system.print(cG.." nil")else system.print(cG.." ".._G[cG])end end;return end;i=string.find(oE," ")local oK=string.sub(oE,0,i-1)local oL=string.sub(oE,i+1)for cF,cG in pairs(c1())do if cG==oK then a2="Variable "..oK.." changed to "..oL;local oM=type(_G[cG])if oM=="number"then oL=y(oL)elseif oM=="boolean"then if string.lower(oL)=="true"then oL=true else oL=false end end;_G[cG]=oL;return end end;a2="No such global variable: "..oK elseif oD=="/copydatabank"then if dbHud_2 then cB(true)else a2="Spare Databank required to copy databank"end elseif oD=="/iphWP"then if AutopilotTargetIndex>0 then system.print(aY.showWayPoint(ac,AutopilotTargetCoords,true))a2="::pos waypoint shown in lua chat"else a2="No target selected in IPH"end elseif oD=="start"then mprnStatus='ON'MPRN_NextTarget()elseif oD=="stop"then currentWayPoint=0;mprnStatus='OFF'end end;function script.onEnter(dp)if radar_1 and not aq and not bI then unit.setTimer("contact",0.1)end end;function script.onLeave(dp)if radar_1 and CollisionSystem then if#bL>650 then dp=tostring(dp)bL[dp]=nil end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_3:
    enter(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_4:
    enter(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_5:
    enter(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_6:
    enter(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_7:
    enter(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_8:
    enter(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_9:
    enter(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_10:
    enter(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
